# 第8章 排序

## 8.1 基本概念和排序方法概述

排序：将一组杂乱无章的数据按一定规律顺次排列起来，即将无序序列**排成一个有序序列**的运算。如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域而言。

![图01：排序方法的分类]([http://](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter8%20Sorting/%E5%9B%BE01%EF%BC%9A%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB.png), '排序方法分类')

按照存储介质可分为：

- **内部排序**：数据量不大、数据在内存，无序内外存交换数据。

- **外部排序**：数据量较大、数据在外存（如：文件排序）。

外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外村，显然外部排序要复杂得多。

按比较器个数可分为：

- **串行排序**：单处理机（同一时刻比较一对元素）

- **并行排序**：多处理机（同一时刻比较多对元素）

按主要操作可分为：

- **比较排序**：用比较的方法，例如：插入排序、交换排序、选择排序、归并排序等。

- **基数排序**：不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。

按辅助空间可分为：

- **原地排序**：辅助空间用量为O(1)的排序方法。（所占的辅助存储空间与参加排序的数据量大小无关）

- **非原地排序**：辅助空间用量超过O(1)的排序方法。

按稳定性可分为：（排序稳定性只对结构类型数据排序有意义）

- **稳定排序**：能够使任何数值相等的元素，排序以后相对次序不变。

- **非稳定排序**：不是稳定排序的方法。

按自然性可分为：

- **自然排序**：输入数据越有序，排序的速度越快的排序方法。

- **非自然排序**：不是自然排序的方法。

本章节主要讨论的是内部、串行、比较排序。

主要内容如图所示：

![图02：主要学习内容](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter8%20Sorting/%E5%9B%BE02%EF%BC%9A%E4%B8%BB%E8%A6%81%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9.png,'主要学习内容')

## 8.2 插入排序

基本思想：每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，值到对象全部插入为止。**即边插入边排序，保证子序列中随时都是排好序的**。

基本操作：有序插入

- 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。

- 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。

插入排序的种类：**直接插入排序**（顺序法定位插入位置）、**二分插入排序**（二分法定位插入位置）、**希尔排序**（缩小增量多变插入排序）。

1. 直接插入排序

    采用**顺序查找法**找到插入位置。

    1. 复制插入元素；

    2. 记录后移，查找插入位置；

    3. 插入到正确位置。

    ```C++
        void InsertSort(SqList &L)
        {
            int i, j;
            for(int i = 2; i <= L.length; ++i)
            {
                if(L.r[i].key < L.r[i-1].key)
                {
                    L.r[0] = L.r[i];            // 复制为哨兵
                    for(int j = i -1; L.r[0].key < L.r[j].key; --j)
                    {
                        L.r[j+1] = L.r[j];  // 记录后移
                    }
                    L.r[j+1] = L.r[0];      // 插入到正确位置
                }
            }
        }
    ```

    实现排序的基本操作有两个：“比较”和“移动”。

    性能分析：当原始数据越接近有序，排序速度越快；最快情况下（输入数据是逆序的，O(n^2)）；平均情况下，耗时差不多是最坏情况下的一半，O（n^2）。

2. 折半插入排序

    查找插入位置时采用折半查找法。

    ```C++
        void BInsertSort(SqList &L)
        {
            for(int i = 2; i <= L.length; i++)
            {
                L.r[0] = L.r[i];    // 当前插入元素存到“哨兵”位置
                low = 1; high = i-1;
                // 采用二分法查找插入位置
                while(low <= high)
                {
                    mid = (low + high) / 2;
                    if(L.r[0].key < L.r[mid].key)) high = mid - 1;
                    else low = mid + 1;
                }   // 循环结束，high+1为插入位置

                // 移动元素
                for(int j = i - 1; j >= high+1; --j)
                {
                    L.r[j+1] = L.r[j];
                }
                L.r[high+1] = L.r[0];       // 插入到正确位置
            }
        }
    ```

    算法效率分析：

    - 折半查找比顺序查找快，所以折半插入排序就平均性能来说比直接插入排序要快；

    - 它所需要的关键码比较次数与待排序对象序列的初始排列无关，仅依赖于对象个数。在插入第i个对象时，需要经过log2i+1次关键码比较，才能确定它应插入的位置；

        - 当n较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差；

        - 在对象的初始排序列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行关键码比较次数要少；

    - 折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列

        - 减少了比较次数，但没有减少移动次数；

        - 平均性能优于直接插入排序。

    时间复杂度为：O(n^2)；空间复杂度为：O(1)；也是一种稳定的排序方法。

3. 希尔排序

    先将整个待排记录序列分割成**若干子序列**，分别进行**直接插入排序**，待整个序列中的记录“**基本有序**”时，再对全体记录进行一次直接插入排序。

    希尔排序算法：逐步缩小增量；多遍插入排序。

    希尔排序特点：

    - 依次移动，移动位置较大，跳跃式地接近排序后的最终位置；

    - 最后一次只需要少量移动；

    - 增量序列必须是递减的，最后一个必须是1；

    - 增量序列应该是互质的。、

    ```C++
        void ShellSort(SqList &L, int dlta[], int t)
        {
            // 按增量序列dlta[0,...,t-1]对顺序表L作希尔排序
            for(k = 0; k < t; k++)
            {
                ShellInsert(L, dlta[k]);    // 一趟增量为dlta[k]的插入排序
            }
        }

        void ShellInsert(SqList &L, int dk)
        {
            // 对顺序表L进行一趟增量为dk的Shell排序，dk为步长因子
            for(int i = dk + 1; i <= L.length; i++)
            {
                if(r[i].key < r[i-dk].key)
                {
                    r[0] = r[i];
                    for(j = i -dk; j > 0 && (r[0].key < r[j].key); j = j - dk)
                    {
                        r[j+dk] = r[j];
                    }
                    r[j+dk] = r[0];
                }
            }
        }
    ```

    性能分析：希尔排序算法效率与**增量序列的取值**有关。

    时间复杂度是n和d的函数：O(n^1.25)~O(1.6n^1.25)；空间复杂度为O(1)；是一种**不稳定**的排序算法；**不宜在链式存储结构上实现**。

## 8.3 交换排序

排序过程中，两两比较，如果发生逆序则交换，知道所有记录都排好序为止。常见的交换排序方法有**冒泡排序**、**快速排序**。

### 8.3.1 冒泡排序

冒泡排序：基于简单交换思想，每趟不断将数据两两比较，并按“前小后大”规则交换。

```C++
    void bubble_sort(SqList &L)
    {
        int m, i, j;
        RedType x;
        for(int m = 1; m <= n-1; m++)
        {
            for(int j = 1; j <= n-m; j++)
            {
                // 如果发生逆序
                if(L.r[j].key > L.r[j+1].key)
                {
                    x = L.r[j];
                    L.r[j] = L.r[j+1];
                    L.r[j+1] = x;
                }
            }
        }
    }
```

优点：每趟结束时，不仅能挤出一个最大值到最后面位置，还能同时部分理顺其他元素；当**一旦某一趟比较时不出现记录交换，说明已经排好序了，就可以结束本算法**。

改进的冒泡排序算法

```C++
    void bubble_sort(SqList &L)
    {
        int m, i, j, flag = 1;
        RedType x;
        for(int m = 1; m <= n-1 && flag == 1; m++)
        {
            flag = 0;
            for(int j = 1; j <= m; j++)
            {
                // 如果发生逆序
                if(L.r[j].key > L.r[j+1].key)
                {
                    flag = 1;   // 发生交换，flag置为1，若本趟没发生变换，flag保持为0；
                    x = L.r[j];
                    L.r[j] = L.r[j+1];
                    L.r[j+1] = x;
                }
            }
        }
    }
```

时间复杂度：最好情况下（正序）比较次数为n-1，移动次数为0；最坏情况下（逆序）比较次数为(1/2 * (n^2-n))，移动次数为(3/2 * (n^2-n))。

冒泡排序**最好**时间复杂度为O(n)；**最坏**时间复杂度为O(n^2)；**平均**时间复杂度为O(n^2)；辅助空间为O(1)；冒泡排序是**稳定**的。

### 8.3.2 快速排序

## 8.4 选择排序

## 8.5 归并排序

## 8.6 基数排序

## 8.7 外部排序
