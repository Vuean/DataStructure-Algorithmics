# 第8章 排序

## 8.1 基本概念和排序方法概述

排序：将一组杂乱无章的数据按一定规律顺次排列起来，即将无序序列**排成一个有序序列**的运算。如果参加排序的数据结点包含多个数据域，那么排序往往是针对其中某个域而言。

![图01：排序方法的分类]([http://](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter8%20Sorting/%E5%9B%BE01%EF%BC%9A%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB.png), '排序方法分类')

按照存储介质可分为：

- **内部排序**：数据量不大、数据在内存，无序内外存交换数据。

- **外部排序**：数据量较大、数据在外存（如：文件排序）。

外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外村，显然外部排序要复杂得多。

按比较器个数可分为：

- **串行排序**：单处理机（同一时刻比较一对元素）

- **并行排序**：多处理机（同一时刻比较多对元素）

按主要操作可分为：

- **比较排序**：用比较的方法，例如：插入排序、交换排序、选择排序、归并排序等。

- **基数排序**：不比较元素的大小，仅仅根据元素本身的取值确定其有序位置。

按辅助空间可分为：

- **原地排序**：辅助空间用量为O(1)的排序方法。（所占的辅助存储空间与参加排序的数据量大小无关）

- **非原地排序**：辅助空间用量超过O(1)的排序方法。

按稳定性可分为：（排序稳定性只对结构类型数据排序有意义）

- **稳定排序**：能够使任何数值相等的元素，排序以后相对次序不变。

- **非稳定排序**：不是稳定排序的方法。

按自然性可分为：

- **自然排序**：输入数据越有序，排序的速度越快的排序方法。

- **非自然排序**：不是自然排序的方法。

本章节主要讨论的是内部、串行、比较排序。

主要内容如图所示：

![图02：主要学习内容](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter8%20Sorting/%E5%9B%BE02%EF%BC%9A%E4%B8%BB%E8%A6%81%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9.png,'主要学习内容')

## 8.2 插入排序

基本思想：每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，值到对象全部插入为止。**即边插入边排序，保证子序列中随时都是排好序的**。

基本操作：有序插入

- 在有序序列中插入一个元素，保持序列有序，有序长度不断增加。

- 起初，a[0]是长度为1的子序列。然后，逐一将a[1]至a[n-1]插入到有序子序列中。

插入排序的种类：**直接插入排序**（顺序法定位插入位置）、**二分插入排序**（二分法定位插入位置）、**希尔排序**（缩小增量多变插入排序）。

1. 直接插入排序

    采用**顺序查找法**找到插入位置。

    1. 复制插入元素；

    2. 记录后移，查找插入位置；

    3. 插入到正确位置。

    ```C++
        void InsertSort(SqList &L)
        {
            int i, j;
            for(int i = 2; i <= L.length; ++i)
            {
                if(L.r[i].key < L.r[i-1].key)
                {
                    L.r[0] = L.r[i];            // 复制为哨兵
                    for(int j = i -1; L.r[0].key < L.r[j].key; --j)
                    {
                        L.r[j+1] = L.r[j];  // 记录后移
                    }
                    L.r[j+1] = L.r[0];      // 插入到正确位置
                }
            }
        }
    ```

    实现排序的基本操作有两个：“比较”和“移动”。

    性能分析：当原始数据越接近有序，排序速度越快；最快情况下（输入数据是逆序的，O(n^2)）；平均情况下，耗时差不多是最坏情况下的一半，O（n^2）。

2. 折半插入排序

    查找插入位置时采用折半查找法。

    ```C++
        void BInsertSort(SqList &L)
        {
            for(int i = 2; i <= L.length; i++)
            {
                L.r[0] = L.r[i];    // 当前插入元素存到“哨兵”位置
                low = 1; high = i-1;
                // 采用二分法查找插入位置
                while(low <= high)
                {
                    mid = (low + high) / 2;
                    if(L.r[0].key < L.r[mid].key)) high = mid - 1;
                    else low = mid + 1;
                }   // 循环结束，high+1为插入位置

                // 移动元素
                for(int j = i - 1; j >= high+1; --j)
                {
                    L.r[j+1] = L.r[j];
                }
                L.r[high+1] = L.r[0];       // 插入到正确位置
            }
        }
    ```

    算法效率分析：

    - 折半查找比顺序查找快，所以折半插入排序就平均性能来说比直接插入排序要快；

    - 它所需要的关键码比较次数与待排序对象序列的初始排列无关，仅依赖于对象个数。在插入第i个对象时，需要经过log2i+1次关键码比较，才能确定它应插入的位置；

        - 当n较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比其最好情况要差；

        - 在对象的初始排序列已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行关键码比较次数要少；

    - 折半插入排序的对象移动次数与直接插入排序相同，依赖于对象的初始排列

        - 减少了比较次数，但没有减少移动次数；

        - 平均性能优于直接插入排序。

    时间复杂度为：O(n^2)；空间复杂度为：O(1)；也是一种稳定的排序方法。

3. 希尔排序

    先将整个待排记录序列分割成**若干子序列**，分别进行**直接插入排序**，待整个序列中的记录“**基本有序**”时，再对全体记录进行一次直接插入排序。

    希尔排序算法：逐步缩小增量；多遍插入排序。

    希尔排序特点：

    - 依次移动，移动位置较大，跳跃式地接近排序后的最终位置；

    - 最后一次只需要少量移动；

    - 增量序列必须是递减的，最后一个必须是1；

    - 增量序列应该是互质的。、

    ```C++
        void ShellSort(SqList &L, int dlta[], int t)
        {
            // 按增量序列dlta[0,...,t-1]对顺序表L作希尔排序
            for(k = 0; k < t; k++)
            {
                ShellInsert(L, dlta[k]);    // 一趟增量为dlta[k]的插入排序
            }
        }

        void ShellInsert(SqList &L, int dk)
        {
            // 对顺序表L进行一趟增量为dk的Shell排序，dk为步长因子
            for(int i = dk + 1; i <= L.length; i++)
            {
                if(r[i].key < r[i-dk].key)
                {
                    r[0] = r[i];
                    for(j = i -dk; j > 0 && (r[0].key < r[j].key); j = j - dk)
                    {
                        r[j+dk] = r[j];
                    }
                    r[j+dk] = r[0];
                }
            }
        }
    ```

    性能分析：希尔排序算法效率与**增量序列的取值**有关。

    时间复杂度是n和d的函数：O(n^1.25)~O(1.6n^1.25)；空间复杂度为O(1)；是一种**不稳定**的排序算法；**不宜在链式存储结构上实现**。

## 8.3 交换排序

排序过程中，两两比较，如果发生逆序则交换，知道所有记录都排好序为止。常见的交换排序方法有**冒泡排序**、**快速排序**。

### 8.3.1 冒泡排序

冒泡排序：基于简单交换思想，每趟不断将数据两两比较，并按“前小后大”规则交换。

```C++
    void bubble_sort(SqList &L)
    {
        int m, i, j;
        RedType x;
        for(int m = 1; m <= n-1; m++)
        {
            for(int j = 1; j <= n-m; j++)
            {
                // 如果发生逆序
                if(L.r[j].key > L.r[j+1].key)
                {
                    x = L.r[j];
                    L.r[j] = L.r[j+1];
                    L.r[j+1] = x;
                }
            }
        }
    }
```

优点：每趟结束时，不仅能挤出一个最大值到最后面位置，还能同时部分理顺其他元素；当**一旦某一趟比较时不出现记录交换，说明已经排好序了，就可以结束本算法**。

改进的冒泡排序算法

```C++
    void bubble_sort(SqList &L)
    {
        int m, i, j, flag = 1;
        RedType x;
        for(int m = 1; m <= n-1 && flag == 1; m++)
        {
            flag = 0;
            for(int j = 1; j <= m; j++)
            {
                // 如果发生逆序
                if(L.r[j].key > L.r[j+1].key)
                {
                    flag = 1;   // 发生交换，flag置为1，若本趟没发生变换，flag保持为0；
                    x = L.r[j];
                    L.r[j] = L.r[j+1];
                    L.r[j+1] = x;
                }
            }
        }
    }
```

时间复杂度：最好情况下（正序）比较次数为n-1，移动次数为0；最坏情况下（逆序）比较次数为(1/2 * (n^2-n))，移动次数为(3/2 * (n^2-n))。

冒泡排序**最好**时间复杂度为O(n)；**最坏**时间复杂度为O(n^2)；**平均**时间复杂度为O(n^2)；辅助空间为O(1)；冒泡排序是**稳定**的。

### 8.3.2 快速排序

快速排序：

- 从需要排序的数据当中，任取一个元素为**中心**；

- 依次比较其他元素，所有比它小的元素一律前放，比它大的元素一律后放，形成**左右两个子表**；

- 对各子表重新选择中心元素并**依此规则调整**，直到每个子表的元素只剩一个。

**基本思想**：通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序。

**具体实现**：选定一个中间数作为参考，所有元素与之比较，小的调到其左边，大的调到其右边。每一趟的子表的形成是采用从两头向中间交替式逼近法；由于每趟中对各子表的操作都相似，可采用**递归算法**。

```C++
    void QSort(SqList &L, int low, int high)    // 对顺序表L快速排序
    {
        if(low < high)
        {
            pivotloc = Partition(L, low, high);
            // 将L.r[low,...,high]一分为二，pivotloc为枢轴元素排好序的位置
            QSort(L, low, pivotloc-1);      // 对低子表递归排序
            QSort(L, pivotloc+1, high);     // 对高子表递归排序
        }
    }

    int Partition(SqList &L, int low, int high)
    {
        L.r[0] = L.r[low];
        pivotkey = L.r[low].key;
        
        // low与high重合时，循环结束
        while(low < high)
        {
            while(low < high && L.r[high].key >= pivotkey) --high;
            // 当high位置上的值比当前值小，循环结束，high位置上的元素搬至low位置上的元素
            L.r[low] = L.r[high];

            while(low < high && L.r[low].key <= pivotkey) ++low;
            // 当low位置上的值比当前值大，循环结束，low位置上的元素被搬至high位置上
            L.r[high] = L.r[low];
        }
        L.r[low] = L.r[0];
        return low;
    }
```

性能分析：时间复杂度O(nlogn)；空间复杂度平均为O(logn)，最坏情况下栈空间可达O(n)。

快速排序是一种**不稳定**的排序方法。且**快速排序不适用于对原本有序或基本有序的记录序列进行排序**。

- **划分元素的选取**是影响时间性能的关键

- 输入数据次序越乱，所选划分元素值的随机性越好，排序速度越快，快速排序**不是自然排方法**。

- 改变划分元素的选取方法，至多只能改变算法平均情况的下的时间性能，无法改变最坏情况下的时间性能。即最坏情况下，快速排序的时间复杂性总是O(n^2)

## 8.4 选择排序

### 8.4.1 简单选择排序

**基本思想**：在待排序的数据中选出最大（小）的元素放在其最终的位置。

1. 首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换；

2. 再通过n-2次比较，从剩余的n-1个记录中找出关键字次少的记录，将它与第二个记录交换；

3. 重复上述操作，共进行n-1趟排序后，排序结束。

```C++
    void SelectSort(SqList &K)
    {
        for(int i = 1; i < L.length; i++)
        {
            k = i;
            for(int j = i + 1; j <= L.length; j++)
            {
                if(L.r[j].key < L.r[k].key) 
                    k = j;  // 记录最小值位置
            }
            if(k != i)
            {
                x = L.r[i];
                L.r[i] = L.r[k];
                L.r[k] = x;
            }
        }
    }
```

时间复杂度：

- 记录移动次数：

    - 最好情况：0；

    - 最坏情况：3*(n-1)

- 比较次数：无论待排序列处于什么状态，选择排序所需进行的“比较“次数都相同。

简单选择排序是**不稳定排序**。

### 8.4.2 堆排序

1. 堆的定义

    堆：若n个元素的序列{a1, a2, ..., an}满足`ai ≤ a2i && ai ≤ a2i+1`或者`ai ≥ a2i && ai ≥ a2i+1`，则分别称该序列为**小根堆**和**大根堆**。

    从堆的定义可以看出，堆实质是满足如下性质的**完全二叉树**：**二叉树中任一非叶子节点均小于（大于）它的孩子结点**。

    **堆排序**：若在输出**堆顶**的最小值（最大值）后，使得剩余n-1个元素的序列重新又建成一个堆，则得到n个元素的次小值（次大值），如此反复，便得到一个有序序列，这个过程称为堆排序。

    实现堆排序重点需解决两个问题：

    1. 如何由一个无序序列建成一个堆？

    2. 如何在堆输出堆顶元素后，调整剩余元素为一个新的堆。

    针对第二个问题，以小根堆为例：

    1. 输出堆顶元素之后，以堆中**最后一个元素替代之**；

    2. 然后将根结点值与左、右子树的根结点值进行比较，并与其中**小者**进行**交换**；

    3. 重复上述操作，直至该结点成为叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为“**筛选**"。

```C++
    void HeapAdjust(elem R[], int s, int m)
    {
        // 已知R[s,...,m]中记录的关键字出R[s]之外均满足堆的定义，本函数调整R[s]的关键字，是R[s,...,m]成为一个大根堆
        rc = R[s];
        for(int j = 2 * s; j <= m; j *= 2)  // 沿key较大的孩子结点向下筛选
        {
            if(j < m && R[j] < R[j+1])
                ++j;    // j为key较大的记录的小标
            if(rc >= R[j]) break;

            R[s] = R[j];
            s = j;
        }
        R[s] rc;
    }
```

2. 堆的建立：

   1. 单节点的二叉树是堆；

   2. 在完全二叉树中所有以叶子节点（序号i>n/2）为根的子树是堆。这样只需要依次将以序号为n/2，n/2-1，...，1的结点为根的子树均调整为堆即可。即对应由n个元素组成的无序序列，“筛选”只需从第n/2个元素开始。

```C++
    for(int i = n/2; i >= 1; i--)
    {
        HeapAdjust(R, i, n);
    }
```

3. 堆排序：

    实质上，堆排序就是利用完全二叉树中父结点与孩子结点之间的内在关系来排序的。

    ```C++
        void HeapSort(elem R[]) // 对R[1]到R[n]进行堆排序
        {
            int i;
            for(int i = n / 2; i >= 1; i--)
            {
                HeapAdjust(R, i, n);        // 建立初始堆
            }
            for(int i = n; i > 1; i--)
            {
                Swap(R[1], R[i]);       // 根与最后一个元素交换
                HeapAdjust(R, 1, i - 1); // 对R[1]到R[i-1]重新建堆
            }
        }
    ```

    性能分析：

    - 初始堆化所需时间不超过O(n)

    - 排序阶段（不含初始堆化）

        - 一次重新堆化所需时间不超过O(logn)

        - n-1次循环所需时间不超过O(nlogn)

    - 堆排序的时间主要耗费在建初始堆和调整建新堆时进行的反复筛选上。堆排序在最坏情况下，其时间复杂度也为O(nlogn)，这是堆排序的最大优点。无论待排序列中的记录是正序还是逆序排列，都不会使堆排序处于“最好”或“最坏”的状态。

    - 另外，堆排序仅需一个记录大小供交换用的辅助存储空间。

    - 然而堆排序是一种**不稳定**的排序方法，它不适用于待排序记录个数n较少的情况，但对于n较大的文件还是很有效的。

## 8.5 归并排序

**归并排序**：将两个或两个以上的有序子序列“归并”为一个有序序列。在内部排序中，通常采用的是**2-路归并排序**。

归并排序的关键问题在于：如何将两个有序序列合成一个有序序列？

时间效率：O(nlogn)；空间效率：O(n)；归并排序是**稳定**的。

## 8.6 基数排序

基数排序也叫**桶排序**或**箱排序**：设置若干个箱子，将关键字为k的记录放入第k个箱子，然后在按序号将非空的连接。

时间效率：O(k*(n+m))，k为关键字个数，m为关键字取值范围；空间效率：O(n)；基数排序是**稳定**的。

## 8.7 外部排序（略）

## 8.8 排序方法比较

![图03：排序方法比较](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter8%20Sorting/%E5%9B%BE03%EF%BC%9A%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83.png,'排序方法比较')

1. 时间性能

    1. 按平均的时间性能来分，有三类排序方法：

        - 时间复杂度为O(nlogn)的方法有：快速排序、堆排序和归并排序，其中以快速排序为最好；

        - 时间复杂度为O(n^2)的有：直接插入排序、冒泡排序和简单选择排序，其中以直接插入为最好，特别是对那些对关键字近似有序的记录序列尤为如此；

        - 时间复杂度为O(n)的排序方法只有：基数排序。

    2. 当待排记录序列按关键字顺序**有序**时，直接插入排序和冒泡排序能达到O(n)的时间复杂度；而对于快速排序而言，这是最不好的情况，此时的时间性能退化为O(n^2)，因此是应该尽量避免的情况。

    3. 简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的分布而改变。

2. 空间性能

    指的是排序过程中所需的辅助空间大小。

    1. 所有的简单排序方法（包括：直接插入、冒泡和简单选择）和堆排序的空间复杂度为O(1)

    2. 快速排序为O(logn)，为栈所需的辅助空间

    3. 归并排序所需辅助空间最多，其空间复杂度为O(n)

    4. 链式基数排序需附设队列首尾指针，则空间复杂度为O(rd)

3. 排序的稳定性

    - 稳定的排序方法指的是，对于两个关键字相等的记录，它们在序列中的相对位置，在排序之前和经过排序之后，没有改变。

    - 当对多关键字的记录序列进行LSD方法排序时，必须采用稳定的排序方法。

    - 对于不稳定的排序方法，只要能举出一个实例说明即可。

    - **快速排序和堆排序是不稳定的排序方法**。

4. 关于“排序方法的时间复杂度的下限”

    - 本章讨论的各种排序方法，除基数排序外，其它方法都是基于“比较关键字"进行排序的排序方法，可以证明，这类排序法可能达到的**最快的时间复杂度为O(nlogn)**。（基数排序不是基于“比较关键字”的排序方法，所以它不受这个限制）。

    - 可以用一棵**判定树**来描述这类基于“比较关键字”进行排序的排序方法。

