# 第4章 串、数组和广义表

字符串一般简称为串。串是一种特殊的线性表，其特殊性体现在数据元素是一个字符，也就是说，**串是一种内容受限的线性表**。

本章后两部分讨论的多维数组和广义表可以看成是线性表的一种扩充，即线性表的数据元素自身又是一个数据结构。高级语言都支持数组，但在高级语言中，重点介绍数组的使用，而本章重点介绍数组的内部实现，并介绍对于一些特殊的二维数组如何实现压缩存储。最后介绍广义表的基本概念和存储结构。

## 4.1 串的定义

**串**(string)(或字符串)是由零个或多个字符组成的有限序列，一般记为：s = "a1a2 … an"。

其中，s是串的名，用双引号括起来的字符序列是串的值；ai(1≤i≤n)可以是字母、数字或其他字符；串中字符的数目n称为串的长度。零个字符的串称为**空串**(null string)，其长度为零。

> 相关术语

- **子串**：一个串中任意个连续的字符组成的子序列(含空串)称为该串的子串。

- **主串**：包含子串的串相应地称为主串。

- **字符位置**：通常称字符在序列中的序号为该字符在串中的位置。

- **子串的位置**：子串的第一个字符在主串中的位置。

- **空格串**：一个或多个空格组成的串，与空串不同。

- **串相等**：当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。

- 所有的空串都是相等的。

## 4.2 案例的引入

## 4.3 串的类型定义、存储结构及其运算

### 4.3.1 串的抽象类型定义

```C++
    ADT string{
        数据对象：
        数据关系：
        基本操作：
            1. StrAssign(&T, chars);    // 串赋值
            2. StrCompare(S, T);        // 串比较
            3. StrLenght(S);            // 求串长
            4. Concat(&T, S1, S2);      // 串连结
            5. SubString(&Sub, S, pos, len);    // 求子串
            6. StrCopy(&T, S);          // 串拷贝
            7. StrEmpty(S);             // 串判空
            8. ClearString(&S);         // 清空串
            9. Index(S, T, pos);        // 子串的位置
            10. Replace(&S, T, V);      // 串替换
            11. StrInsert(&S, pos, T);  // 子串插入
            12. StrDelete(&S, pos, len);    // 子串删除
            13. DestoryString(&S);      // 串销毁
    }
```

### 4.3.2 串的存储结构

串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构：**顺序存储和链式存储**。

1. 串的顺序存储结构

    类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述：

    ```C++
        #define MAXLEN 255
        struct SString{
            char ch[MAXLEN+1];
            int length;
        };
    ```

    其中，MAXLEN表示串的最大长度，ch是存储字符串的一维数组，每个分量存储一个字符，length表示字符串的当前长度。其中，后面算法描述当中所用到的顺序存储的字符串都是从下标为1的数组分量开始存储的，下标为0的分量闲置不用。

2. 串的链式存储结构

    顺序串的插入和删除操作不方便，需要移动大量的字符。因此，可采用单链表方式存储串。由于串结构的特殊性——结构中的每个数据元素是一个字符，则在用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。

    ![串值的链表存储方式](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/%E4%B8%B2%E5%80%BC%E7%9A%84%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png)

    如图(a)中所示，结点大小为4，图(b)，结点大小为1。

    - 串的链式存储结构——块链结构

    ```C++
        #define CHUNKSIZE 80    // 块的大小可自由定义
        struct Chunk{
            char ch[CHUNKSIZE];
            Chunk* next;
        };
        
        struct LString{
            Chunk *head, *tail; // 串的头指针和尾指针
            int curlen; // 串当前的长度
        };  // 字符串的块链结构
    ```

### 4.3.3 串的模式匹配算法

子串的定位运算通常称为串的**模式匹配**或**串匹配**。即算法目的：确定主串中所含子串（模式串）第一次出现得位置。

串的模式匹配设有两个字符串S和T，设S为主串，也称正文串；设T为子串，也称为模式。在主串S中查找与模式T相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串S中出现的位置。

算法种类包括有：BF算法、KMP算法。

1. BF算法

    Brute-Force简称BF算法，亦称简单匹配算法，采用穷举法的思路：从S的每一个字符开始依次与T的字符进行匹配。

    > 算法设计思想

    Index(S, T, pos)

    1. 将主串的第pos个字符和模式串的第一个字符比较，

        - 若相等，继续逐个比较后续字符；

        - 若不等，从主串的下一字符起，重新与模式串的第一个字符比较。

    2. 直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。

    3. 否则，匹配失败，返回值0

    > 算法4.1——BF算法描述

    ```C++
        int Index_BF(SString S, SString T){
            int i = 1, j = 1;
            while(i <= S.lenght && j <= T.length){
                if(S.ch[i] == T.ch[j]){
                    ++i;
                    ++j;
                }else{
                    // 主串、子串指针回溯重新开始下一次匹配
                    i = i - j + 2;
                    j = 1;
                }
            }
            if(j >= T.lenght) return i - T.lenght;
            else return 0;
        }
    ```

    当m远小于n时，算法复杂度为O(n*m)，平均复杂度为O(nm/2)。

2. KMP算法

    KMP算法，利用已经部分匹配的结果而加快模式串的滑动速度，且主串S的指针i**不必回溯**！可提速到O(n+m)

    重点在于定义`next[j]`函数，表明当模式中第j个字符与主串中相应字符失配时，在模式中需要重新和主串中该字符进行比较的字符的位置。

    ![next_j]()

    > KMP算法

    ```C++
        int Index_KMP(SString S, SString T, int pos){
            int i = pos, j = 1;
            while(i < S.length && j < T.length){
                if(j == 0 || S.ch[i] == T.ch[j]){
                    i++;
                    j++;
                }else{
                    j = next[j];    // i不变，j后退
                }
            }
            if(j > T.length) return i - T.length;   // 匹配成功
            else return 0;
        }

        void get_next(SString T, int& next[]){
            int i = 1, next[1] = 0, j = 0;
            while(i < T.lenght){
                if(j == 0 || T.ch[i] == T.ch[j]){
                    ++i;
                    next[i] = j;
                }else{
                    j = next[j];
                }
            }
        }
    ```

    对next进行修正，改进：

    ```C++
        void get_nextval(SString T, int& nextval[]){
        int i = 1, nextval[1] = 0, j = 0;
        while(i < T.lenght){
            if(j == 0 || T.ch[i] == T.ch[j]){
                ++i;
                ++j;
                if(T.ch[i] != T.ch[j]) nextval[i] = j;
                else nextval[i] = nextval[j];
            }else{
                j = nextval[j];
            }
        }
    }
    ```

## 4.4 数组

### 4.4.1 数组定义和特点

数组：按一定格式排列起来的具有相同类型的数据元素的集合。

> 一维数组

一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组。

一维数组的逻辑结构：线性结构。定长的线性表。

声明格式：`数据类型 变量名称[长度]`；

> 二维数组

二维数组：若一维数组中的数据元素又是一维数组结构，则称为二维数组。

二维数组的逻辑结构：

- 非线性结构：每一个数据元素既在一个行表中，又在一个列表中。

- 线性结构定长的线性表：该线性表的每个数据元素也是一个定长的线性表。

声明格式：`数据类型 变量名称[行数][列数]`；

> 多维数组

三维数组：若二维数组中的元素又是一个一维数组，则称作三维数组。

n维数组：若n-1维数组中的元素又是一个一维数组结构，则称作n维数组。

结论：线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。

数组特点：**结构固定**，定义后，维数和维界不再改变。

数组基本操作：除了结构的初始化和销毁之外，只有**取元素**和**修改元素值**的操作。

### 4.4.2 数组的抽象数据类型定义

以二维数组为例，二维数组的抽象数据类型的数据对象和数据关系的定义：

n=2（维数为2，二维数组）

b1：第1维长度（行数）

b2：第2维长度（列数）

aj1j2：第1维下标为j1，第2维下标为j2

### 4.4.3 数组的顺序存储

在数组存储过程中，数组可以是多维的，但存储数据元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决将多维关系映射到一维关系的问题。

针对二维数组，可以以行序为主序(C、PASCAL、JAVA、Basic)；也可以是列序为主序(FORTRAN)。

![n维数组元素地址](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/n%E7%BB%B4%E6%95%B0%E7%BB%84.png)

### 4.4.4 特殊矩阵的压缩存储

矩阵的常规存储：将矩阵描述为一个二维数组。

矩阵的常规存储的特点：可以对其元素进行随机存取；矩阵运算非常简单；存储的密度为1。

但是对于不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多。特殊矩阵主要包括**对称矩阵、三角矩阵和对角矩阵**等，以及稀疏矩阵：矩阵中非零元素的个数较少（一般小于5%）

因此可以采用矩阵压缩存储：为多个相同的非零元素只分配一个存储空间，对零元素不分配空间。

1. 对称矩阵：

    特点：在nxn的矩阵a中，满足aij = aji

    存储方法：只存储下（或者上）三角（包括主对角线）的数据元素。共占用n(n+1)/2个元素空间。

    对称矩阵可以以行序为主序将元素存放在一个一维数组`sa[n(n+1)/2]`中，其中aij存放在(i*(i-1)/2)+(j-1)位置。

2. 三角矩阵

    特点：特点对角线以下（或者以上）的数据元素（不包括对角线全部为常数c。

    存储方法：重复元素c共享一个元素存储空间，共占用n(n+1)/2+1个元素空间。

3. 对角矩阵

    特点：在nxn的方阵中，所有非零元素都集中在以主对角线为中心的带状区域中，区域外的值全为0，则称为对角矩阵。常见的有三对角矩阵、五对角矩阵、七对角矩阵等。

    存储方法：可按某个原则（或以行为主，或以对角线的顺序）将其压缩存储到一维数组上。

4. 稀疏矩阵存储

    稀疏矩阵：在mxn的矩阵中，有超过95%的元素位零，非零元素仅不到5%。

    - 三元组法：

        三元组顺序表，又称为**有序的双下标法**

        压缩存储原则：可通过三元组法来表示稀疏矩阵，三元组：(i, j, aij)。即存各非零元素的值、行列位置和矩阵的行列数。

        其中，为更为可靠描述，通常会加上总体的描述信息：总行数、总列数、非零元素总个数。

        优点：非零元在表中按行序有序存储，因此**便于进行依行顺序处理的矩阵运算**。

        缺点：**不能随机存取**。若按行号存取某一行中的非零元，则需从头开始进行查找。

    - 十字链表法

        稀疏矩阵的链式存储结构：

        优点：它能够**灵活地插入**因运算而产生的新的非零元素，**删除**因运算而产生的新的零元素，实现矩阵的各种运算。

        在十字链表中，矩阵的每一个非零元素用一个结点表示，该结点除了(row, col, value)以外，还要有两个域：

        - right：用于链接同一行中的下一个非零元素；

        - down：用以链接同一列中的下一个非零元素。

        同时，为了方便元素查找，可为每一行、每一列添加头指针结点。

## 4.5 广义表

### 4.5.1 广义表的定义

广义表是线性表的推广，也称为列表。广泛地用于人工智能等领域的表处理语言LISP语言，把广义表作为基本的数据结构，就连程序也表示为一系列的广义表。

广义表(又称列表Lists)是n≥0个元素a0, a1, a2, ..., an-1的有限序列，其中每一个ai可以是单个元素，也可以是广义表，分别称为广义表LS的原子和子表。

广义表通常记作：LS=(a1, a2, ..., an)，其中：LS为表名，n为表的长度，每一个元素ai为表的元素。

习惯上，一般用大写字母表示广义表，小写字母表示原子。

表头：若LS非空，则第一个元素a1就是表头，记作head(LS)=a1。其中，表头可以是原子，也可以是子表。

表尾：除表头外的其他元素组成的表。记作tail(LS) = (a2,...,an)。其中表尾不是一个元素，而实一个子表。

```C++
    A = ()  // 空表，长度为零
    B = (())    // 长度为1，表头、表尾均为()
    C = (a, (b, c)) // 长度为2，由原子a和子表(b,c)构成，表头为a；表尾为((b, c))
    D = (x, y, z)   // 长度为3，每一项都是原子，表头为x，表尾为(y, z)
    E = (C, D)  // 长度为2，每一项都是子表，表头为C，表尾为(D)
    F = (a, F)  // 长度为2，第一项为原子，第二项为本身。表头为a；表尾为(F)
```

> 广义表的性质

1. 广义表中的数据元素有相对次序；一个直接前驱和一个直接后继

2. 广义表的长度定义为最外层所包含元素的个数；

3. 广义表的深度定义为该广义表展开后所含括号的重数；其中，原子的深度为0，空表的深度为1。

4. 广义表可以为其他广义表共享；

5. 广义表可以是一个递归的表，即广义表也可以是其本身的一个子表。

6. 广义表是一个多层次的结构，可以用图形象地表示。

> 广义表与线性表的区别

**广义表可以看成是线性表的推广，线性表是广义表的特例**。

广义表的结构相当灵活，在某种前提下，它可以兼容线性表、数组、树和有向图等各种常用的数据结构。

**当二维数组的每行（或每列）作为子表处理时，二维数组即为一个广义表**。

另外，树和有向图也可以用广义表来表示。由于广义表不仅集中了线性表、数组、树和有向图等常见数据结构的特点，而且可有效地利用存储空间，因此在计算机的许多应用领域都有成功使用广义表的实例。

> 广义表的运算

1. 取表头GetHead(LS): 取出的表头为非空广义表的第一个元素，它可以是一个单原子，也可以是一个子表。

2. 取表尾GetTail(LS): 取出的表尾为除去表头之外，由其余元素构成的表。即**表尾一定是一个广义表**。

### 4.5.2 广义表的存储

由于广义表中的数据元素可以有不同的结构（或是原子，或是列表），因此难以用顺序存储结构表示，通常采用链式存储结构。常用的链式存储结构有两种，**头尾链表的存储结构**和**扩展线性链表的存储结构**。

## 4.6 案例分析与实现
