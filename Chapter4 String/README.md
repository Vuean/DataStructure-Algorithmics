# 第4章 串、数组和广义表

字符串一般简称为串。串是一种特殊的线性表，其特殊性体现在数据元素是一个字符，也就是说，**串是一种内容受限的线性表**。

本章后两部分讨论的多维数组和广义表可以看成是线性表的一种扩充，即线性表的数据元素自身又是一个数据结构。高级语言都支持数组，但在高级语言中，重点介绍数组的使用，而本章重点介绍数组的内部实现，并介绍对于一些特殊的二维数组如何实现压缩存储。最后介绍广义表的基本概念和存储结构。

## 4.1 串的定义

**串**(string)(或字符串)是由零个或多个字符组成的有限序列，一般记为：s = "a1a2 … an"。

其中，s是串的名，用双引号括起来的字符序列是串的值；ai(1≤i≤n)可以是字母、数字或其他字符；串中字符的数目n称为串的长度。零个字符的串称为**空串**(null string)，其长度为零。

> 相关术语

- **子串**：一个串中任意个连续的字符组成的子序列(含空串)称为该串的子串。

- **主串**：包含子串的串相应地称为主串。

- **字符位置**：通常称字符在序列中的序号为该字符在串中的位置。

- **子串的位置**：子串的第一个字符在主串中的位置。

- **空格串**：一个或多个空格组成的串，与空串不同。

- **串相等**：当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。

- 所有的空串都是相等的。

## 4.2 案例的引入

## 4.3 串的类型定义、存储结构及其运算

### 4.3.1 串的抽象类型定义

```C++
    ADT string{
        数据对象：
        数据关系：
        基本操作：
            1. StrAssign(&T, chars);    // 串赋值
            2. StrCompare(S, T);        // 串比较
            3. StrLenght(S);            // 求串长
            4. Concat(&T, S1, S2);      // 串连结
            5. SubString(&Sub, S, pos, len);    // 求子串
            6. StrCopy(&T, S);          // 串拷贝
            7. StrEmpty(S);             // 串判空
            8. ClearString(&S);         // 清空串
            9. Index(S, T, pos);        // 子串的位置
            10. Replace(&S, T, V);      // 串替换
            11. StrInsert(&S, pos, T);  // 子串插入
            12. StrDelete(&S, pos, len);    // 子串删除
            13. DestoryString(&S);      // 串销毁
    }
```

### 4.3.2 串的存储结构

串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的存储结构：**顺序存储和链式存储**。

1. 串的顺序存储结构

    类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区，则可用定长数组如下描述：

    ```C++
        #define MAXLEN 255
        struct SString{
            char ch[MAXLEN+1];
            int length;
        };
    ```

    其中，MAXLEN表示串的最大长度，ch是存储字符串的一维数组，每个分量存储一个字符，length表示字符串的当前长度。其中，后面算法描述当中所用到的顺序存储的字符串都是从下标为1的数组分量开始存储的，下标为0的分量闲置不用。

2. 串的链式存储结构

    顺序串的插入和删除操作不方便，需要移动大量的字符。因此，可采用单链表方式存储串。由于串结构的特殊性——结构中的每个数据元素是一个字符，则在用链表存储串值时，存在一个“结点大小”的问题，即每个结点可以存放一个字符，也可以存放多个字符。

    ![串值的链表存储方式](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter4%20String/%E4%B8%B2%E5%80%BC%E7%9A%84%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png)

    如图(a)中所示，结点大小为4，图(b)，结点大小为1。

    - 串的链式存储结构——块链结构

    ```C++
        #define CHUNKSIZE 80    // 块的大小可自由定义
        struct Chunk{
            char ch[CHUNKSIZE];
            Chunk* next;
        };
        
        struct LString{
            Chunk *head, *tail; // 串的头指针和尾指针
            int curlen; // 串当前的长度
        };  // 字符串的块链结构
    ```

### 4.3.3 串的模式匹配算法

子串的定位运算通常称为串的**模式匹配**或**串匹配**。即算法目的：确定主串中所含子串（模式串）第一次出现得位置。

串的模式匹配设有两个字符串S和T，设S为主串，也称正文串；设T为子串，也称为模式。在主串S中查找与模式T相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串S中出现的位置。

算法种类包括有：BF算法、KMP算法。

1. BF算法

    Brute-Force简称BF算法，亦称简单匹配算法，采用穷举法的思路：从S的每一个字符开始依次与T的字符进行匹配。

    > 算法设计思想

    Index(S, T, pos)

    1. 将主串的第pos个字符和模式串的第一个字符比较，

        - 若相等，继续逐个比较后续字符；

        - 若不等，从主串的下一字符起，重新与模式串的第一个字符比较。

    2. 直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。

    3. 否则，匹配失败，返回值0

    > 算法4.1——BF算法描述

    ```C++
        int Index_BF(SString S, SString T){
            int i = 1, j = 1;
            while(i <= S.lenght && j <= T.length){
                if(S.ch[i] == T.ch[j]){
                    ++i;
                    ++j;
                }else{
                    // 主串、子串指针回溯重新开始下一次匹配
                    i = i - j + 2;
                    j = 1;
                }
            }
            if(j >= T.lenght) return i - T.lenght;
            else return 0;
        }
    ```

    当m远小于n时，算法复杂度为O(n*m)，平均复杂度为O(nm/2)。

2. KMP算法

    KMP算法，利用已经部分匹配的结果而加快模式串的滑动速度，且主串S的指针i**不必回溯**！可提速到O(n+m)

    重点在于定义`next[j]`函数，表明当模式中第j个字符与主串中相应字符失配时，在模式中需要重新和主串中该字符进行比较的字符的位置。

    ![next_j]()

    > KMP算法

    ```C++
        int Index_KMP(SString S, SString T, int pos){
            int i = pos, j = 1;
            while(i < S.length && j < T.length){
                if(j == 0 || S.ch[i] == T.ch[j]){
                    i++;
                    j++;
                }else{
                    j = next[j];    // i不变，j后退
                }
            }
            if(j > T.length) return i - T.length;   // 匹配成功
            else return 0;
        }

        void get_next(SString T, int& next[]){
            int i = 1, next[1] = 0, j = 0;
            while(i < T.lenght){
                if(j == 0 || T.ch[i] == T.ch[j]){
                    ++i;
                    next[i] = j;
                }else{
                    j = next[j];
                }
            }
        }
    ```

    对next进行修正，改进：

    ```C++
        void get_nextval(SString T, int& nextval[]){
        int i = 1, nextval[1] = 0, j = 0;
        while(i < T.lenght){
            if(j == 0 || T.ch[i] == T.ch[j]){
                ++i;
                ++j;
                if(T.ch[i] != T.ch[j]) nextval[i] = j;
                else nextval[i] = nextval[j];
            }else{
                j = nextval[j];
            }
        }
    }
    ```

## 4.4 数组
