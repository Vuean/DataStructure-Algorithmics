# 第5章 树和二叉树

## 5.1 树与二叉树的定义

### 5.1.1 树的定义

树(非线性结构)是以分支关系定义的层次结构：结点之间有分支、具有层次关系。

> 树的定义

树(Tree)是n(n≥0)个结点的**有限集**。

    - 若n=0，称为空树；

    - 若n>0，则它满足如下两个条件：

    1. **有且仅有一个**特定的称为根(Root)的结点；

    2. **其余结点**可分m(m≥0)个互不相交的有限集T1，T2，T3...Tm，其中每一个集合本身又是一棵树，并称为根的子树(SubTree)。

树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。树还可有其他的表示形式：嵌套集合表示
（即是一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个）；广义表的形式表示，根作为由子树森林组成的表的名字写在表的左边；凹入表示法（类似书的编目）。

### 5.1.2 树的基本术语

![树结构示例](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E6%A0%91%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png)

1. **根节点**：非空树中无前驱结点的结点；

2. **结点**：树中的一个独立单元。包含一个数据元素及若于指向其子树的分支，如图中的A 、B 、C 、D等。

3. **结点的度**：结点拥有的子树数称为结点的度。例如，A的度为3，C的度为1，F的度为0。

4. **树的度**：树的度是树内各结点度的最大值。图中所示的树的度为3。

5. **叶子**：度为0的结点称为叶子或终端结点。结点K、L、F、G、M、I、J都是树的叶子。

6. **非终端结点**：度不为0的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。

7. **双亲和孩子**：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，B的双亲为A，B的孩子有E和F。

8. **兄弟**：同一个双亲的孩子之间互称兄弟。例如，H、I和J互为兄弟。

9. **祖先**：从根到该结点所经分支上的所有结点。例如，M的祖先为A、D和H。

10. **子孙**：以某结点为根的子树中的任一结点都称为该结点的子孙。如B的子孙为E、K、L和F。

11. **层次**：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加1。

12. **堂兄弟**：双亲在同一层的结点互为堂兄弟。例如，结点G与E、F、H、I、J互为堂兄弟。

13. **树的深度**：树中结点的最大层次称为**树的深度或高度**。图中所示的树的深度为4。

14. **有序树和无序树**：如果将树中结点的各子树从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。

15. **森林**：是m(m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。

> 树结构和线性结构的比较

![树结构和线性结构的比较](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E6%A0%91%E7%BB%93%E6%9E%84%E5%92%8C%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%9A%84%E6%AF%94%E8%BE%83.png)

### 5.1.3 二叉树的定义

引入二叉树的原因：

    - 二又树的结构最简单，规律性最强；

    - 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。

二叉树是n(n≥0)个结点的有限集，它或者是空集(n=0)，或者由一个根结点及**两棵互不相交**的分别称作这个根的左子树和右子树的二又树组成。

1. 每个结点最多有俩孩子，二叉树中不存在度大于2的结点。

2. 子树有左右之分，其次序不能颠倒。

3. 二叉树可以是空集合，根可以有空的左子树或空的右子树。

二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。

需要注意的是：**二叉树不是树的特殊情况，与树是两个概念**。

二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要区分，说明它是左子树，还是右子树。

树中当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二叉树与树的最主要的差别。

    因此，考虑到二叉树的特点，思考：具有三个结点的二叉树可能有几种不同形态？普通树有几种不同形态？

    二叉树有五种形态；树有两种形态：

![二叉树](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BD%A2%E6%80%81.png)

![树](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E6%A0%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BD%A2%E6%80%81.png)

> 二叉树的5种基本形态

二叉树的5种基本形态包括有：空二叉树、根和空的左右子树、根和左子树、根和右子树、根和左右子树。

![二叉树的5种基本形态](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81.png)

## 5.2 案例引入

> 案例5.1：数据压缩的问题

将数据文件转换成由0、1组成的二进制串，称之为编码。

等长编码方案、不等长编码方案1、不等长编码方案2

> 案例5.2：利用二叉树求解表达式的值

一般情况下，一个表达式由一个运算符和两个操作数构成，两个操作数之间有次序之分，并且操作数本身也可以是表达式，这个结构类似于二叉树，因此可以利用二叉树来表示表达式。

## 5.3 树和二叉树的抽象数据类型定义

根据树的结构定义，加上树的一组基本操作就构成了树的抽象数据类型定义。

    ADT BinaryTree{
        // 数据对象D：
        // 数据关系R：
        // 基本操作P：
    }ADT BinaryTree;

## 5.4 二叉树的性质和存储结构

### 5.4.1 二叉树的性质

性质1：在二叉树的第i层上至多有2^(i-1)个结点(i≥1)

性质2：深度为k的二叉树一共至多有2^k-1 个结点(k≥1)

性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2+1。即叶子结点的数目等于度为2的结点数为n2，再加1。

> 两种特殊形式的二叉树

1. 满二叉树

    满二叉树：深度为k且含有2^k-1个结点的二叉树。

    特点：

    - 每一层上的结点数都是最大结点数（即每层都满）

    - 叶子节点全部在最底层。

    对满二叉树结点位置进行编号，按照从根结点开始，自**上而下，自左而右**进行编号，可以发现每一结点位置都有元素。

    满二叉树在同样深度的二叉树中**结点个数最多**。

    满二叉树在同样深度的二叉树中**叶子结点个数最多**。

2. 完全二叉树

    完全二叉树：深度为k的，有n个结点的二叉树，当且仅当其**每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时**，称之为完全二叉树。

    同理，在满二叉树中，从最后一个结点开始，**连续去掉任意**个结点，即是一棵完全二叉树。

    完全二叉树的特点是：

    - 叶子结点只可能在层次最大的两层上出现；

    - 对任一结点，若其右分支下的子孙(即右子树)的最大层次为i，则其左分支下的子孙(左子树)的最大层次必为i或i+1。

性质4：具有n个结点的完全二叉树的深度为⌊log2n⌋ + 1。

性质5：如果对一棵有n个结点的完全二叉树(其深度为⌊log2n⌋+ 1)的结点按层序编号(从第1层到第⌊log2n⌋+1层，每层从左到右)，则对任一结点i(1≤i≤n)，有：

1. 如果i=1，则结点1是二叉树的根，无双亲；如果i>1，则其双亲是结点⌊i/2⌋。

2. 如果2i>n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i。

3. 如果2i+1>n，则结点无右孩子；否则其右孩子是结点2i+1。

性质5表明了完全二叉树中**双亲结点编号与孩子结点编号**之间的关系。

### 5.4.2 二叉树的存储结构

二叉树的存储结构主要有顺序存储结构和链式存储结构，其中链式存储结构又分为二叉链表和三叉链表。

二叉树的顺序存储实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。

    ```C++
        // 二叉树顺序存储表示
        #define MAXSIZE 100
        Typedef TElemType SqBiTree[MAXSIZE];
        SqBiTree bt;
    ```

二叉树的顺序存储缺点：存储密度低，适合存储满二叉树和完全二叉树。

> 二叉树的链式存储结构

    ```C++
        typedef struct BiNode{
            TElemType data;
            BiNode *lchild, *rchild;
        }BiNode, *BiTree;
    ```

在n个结点的二叉表中，有n+1个空指针域。

三叉链表即在二叉链表的基础上增加一个指向父节点的指针。

    ```C++
        typedef struct TriNode{
            TElemType data;
            TriNode *lchild, *parent, *rchild;
        }TriNode, *TriTree;
    ```

## 5.5 遍历二叉树和线索二叉树

### 5.5.1 遍历二叉树

- 遍历定义：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。

- 遍历目的：得到树中所有结点的一个线性排列。

- 遍历用途：它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。

- 遍历方法：规定在先左后右的情况下，主要遍历方法有三种：先序遍历、中序遍历、后续遍历。

1. 三种遍历方法描述如下：

    ![遍历方法描述](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB.png)

    1. 先序遍历

        访问步骤，若二叉树为空，则空操作；否则：

        1. 访问根节点；

        2. 先续遍历左子树；

        3. 先续遍历右子树。

    2. 中序遍历

        访问步骤，若二叉树为空，则空操作；否则：

        1. 中序遍历左子树；

        2. 访问根结点；

        3. 中序遍历右子树。

    3. 后续遍历

        访问步骤，若二叉树为空，则空操作；否则：

        1. 后续遍历左子树；

        2. 后续遍历右子树；

        3. 访问根结点。

2. 根据遍历顺序确定二叉树

    - 若二叉树中各结点的值均不同，则二叉树结点的先序序列、中序序列、后序列都是唯一的。

    - 由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树

    例题：已知二叉树的先序和中序序列，构造出相应的二叉树：**可以先由先序序列确定根，由中序确定左右子树**。

    已知中序序列和后序序列，**由后序遍历可知，根结点必在后续序列尾部**。

3. 遍历的算法实现——先序遍历

    二叉树先续遍历算法（递归）

        ```C++
            status PreOrderTraverse(BiTree T){
                if(T == NULL) return OK;    // 空二叉树
                else{
                    visit(T);// 访问根结点
                    PreOrderTraverse(T->lchild);    // 递归遍历左子树
                    PreOrderTraverse(T->rchild); // 递归遍历右子树
                }
            }
        ```

4. 遍历算法实现——中序遍历

    二叉树中序遍历算法（递归）

        ```C++
            status InOrderTraverse(BiTree T){
                if(T == NULL) return OK;    // 空二叉树
                else{
                    InOrderTraverse(T->lchild);    // 递归遍历左子树
                    visit(T);// 访问根结点
                    InOrderTraverse(T->rchild); // 递归遍历右子树
                }
            }
        ```
5. 遍历算法实现——后序遍历

    二叉树后序遍历算法（递归）

        ```C++
            status PostOrderTraverse(BiTree T){
                if(T == NULL) return OK;    // 空二叉树
                else{
                    PostOrderTraverse(T->lchild);    // 递归遍历左子树
                    PostOrderTraverse(T->rchild); // 递归遍历右子树
                    visit(T);// 访问根结点
                }
            }
        ```

6. 遍历算法分析

    - 如果去掉输出语句，从递归的角度看，三种算法是完全相同的，或说这三种算法的访问路径是相同的，只是访问结点的时机不同。

    - 时间效率：O(n)；每个结点只访问一次

    - 空间效率：O(n)；栈占用的最大辅助空间

7. 遍历二叉树的非递归算法

    中序遍历非递归算法：二叉树中序遍历的非递归算法的关键在于：**在中序遍历过某节点的整个左子树后，如何找到该接点的根以及右子树**。

    基本思想：

    - 建立一个空栈S，指针p指向根结点

    - 申请一个结点空间q，用来存放栈顶弹出的元素。

    - 当p非空或者栈S非空时，循环执行以下操作：

        - 如果p非空，则将p进栈，p指向该结点的左孩子；

        - 如果p为空，则弹出栈顶元素并访问，将p指向该结点的右孩子。

    中序遍历非递归算法实现：

        ```C++
            Status InOrderTraverse(BiTree T){
                BiTree p; InitStack(S); p = T;
                while(p || !StackEmpty(S)){
                    if(p){ // 不为空
                        Push(S, p);
                        p = p->lchild;
                    }
                    else{
                        Pop(S, q);
                        print("%c", q->data);
                        p = q->rchild;
                    }
                }
                return OK;
            }
        ```

    无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n，则空间复杂度也为O(n)。

8. 二叉树的层次遍历

    对于一颗二叉树，从根结点开始，按**从上到下、从左到右**的顺序访问每一个结点。每一个结点仅仅访问一次。

    算法思路：

    - 将根结点入队；

    - 队不为空时循环：从队列中出列一个结点*p，访问它：

        - 若它右左孩子结点，将左孩子结点入队；

        - 若它有右孩子结点，将右孩子结点入队。

    二叉树层次遍历算法实现：

        ```C++
            typedef struct{
                BTNode data[MaxSize];   // 存放队中元素
                int front, rear;        // 队头和队尾指针
            }SqQueue;   // 顺序循环队列类型

            void LevelOrder(BTNode *b){
                BTNode* p;
                SqQueue* qu;
                InitQueue(sqQueue); // 初始化队列
                enQueue(qu, b);     // 根结点指针入队
                while(!QueueEmpty(qu)){
                    // 队不为空，则循环
                    deQueue(qu, p); // 出队结点p
                    cout << p->data;
                    if(p->lchild != NULL){
                        // 有左孩子时将其入队
                        enQueue(qu, p->lchild);
                    }
                    if(p->rchild != NULL){
                        // 有右孩子时将其入队
                        enQueue(qi, p->rchild);
                    }
                }
            }
        ```

9. 二叉树遍历算法的应用——二叉树的建立(算法5.3)
