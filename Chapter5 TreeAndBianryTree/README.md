# 第5章 树和二叉树

## 5.1 树与二叉树的定义

### 5.1.1 树的定义

树(非线性结构)是以分支关系定义的层次结构：结点之间有分支、具有层次关系。

> 树的定义

树(Tree)是n(n≥0)个结点的**有限集**。

    - 若n=0，称为空树；

    - 若n>0，则它满足如下两个条件：

    1. **有且仅有一个**特定的称为根(Root)的结点；

    2. **其余结点**可分m(m≥0)个互不相交的有限集T1，T2，T3...Tm，其中每一个集合本身又是一棵树，并称为根的子树(SubTree)。

树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。树还可有其他的表示形式：嵌套集合表示
（即是一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个）；广义表的形式表示，根作为由子树森林组成的表的名字写在表的左边；凹入表示法（类似书的编目）。

### 5.1.2 树的基本术语

![树结构示例](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E6%A0%91%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B.png)

1. **根节点**：非空树中无前驱结点的结点；

2. **结点**：树中的一个独立单元。包含一个数据元素及若于指向其子树的分支，如图中的A 、B 、C 、D等。

3. **结点的度**：结点拥有的子树数称为结点的度。例如，A的度为3，C的度为1，F的度为0。

4. **树的度**：树的度是树内各结点度的最大值。图中所示的树的度为3。

5. **叶子**：度为0的结点称为叶子或终端结点。结点K、L、F、G、M、I、J都是树的叶子。

6. **非终端结点**：度不为0的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。

7. **双亲和孩子**：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，B的双亲为A，B的孩子有E和F。

8. **兄弟**：同一个双亲的孩子之间互称兄弟。例如，H、I和J互为兄弟。

9. **祖先**：从根到该结点所经分支上的所有结点。例如，M的祖先为A、D和H。

10. **子孙**：以某结点为根的子树中的任一结点都称为该结点的子孙。如B的子孙为E、K、L和F。

11. **层次**：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加1。

12. **堂兄弟**：双亲在同一层的结点互为堂兄弟。例如，结点G与E、F、H、I、J互为堂兄弟。

13. **树的深度**：树中结点的最大层次称为**树的深度或高度**。图中所示的树的深度为4。

14. **有序树和无序树**：如果将树中结点的各子树从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。

15. **森林**：是m(m≥0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。

> 树结构和线性结构的比较

![树结构和线性结构的比较](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E6%A0%91%E7%BB%93%E6%9E%84%E5%92%8C%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E7%9A%84%E6%AF%94%E8%BE%83.png)

### 5.1.3 二叉树的定义

引入二叉树的原因：

    - 二又树的结构最简单，规律性最强；

    - 可以证明，所有树都能转为唯一对应的二叉树，不失一般性。

二叉树是n(n≥0)个结点的有限集，它或者是空集(n=0)，或者由一个根结点及**两棵互不相交**的分别称作这个根的左子树和右子树的二又树组成。

1. 每个结点最多有俩孩子，二叉树中不存在度大于2的结点。

2. 子树有左右之分，其次序不能颠倒。

3. 二叉树可以是空集合，根可以有空的左子树或空的右子树。

二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。

需要注意的是：**二叉树不是树的特殊情况，与树是两个概念**。

二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要区分，说明它是左子树，还是右子树。

树中当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二叉树与树的最主要的差别。

    因此，考虑到二叉树的特点，思考：具有三个结点的二叉树可能有几种不同形态？普通树有几种不同形态？

    二叉树有五种形态；树有两种形态：

![二叉树](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BD%A2%E6%80%81.png)

![树](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E6%A0%91%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BD%A2%E6%80%81.png)

> 二叉树的5种基本形态

二叉树的5种基本形态包括有：空二叉树、根和空的左右子树、根和左子树、根和右子树、根和左右子树。

![二叉树的5种基本形态](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%94%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%BD%A2%E6%80%81.png)

## 5.2 案例引入

> 案例5.1：数据压缩的问题

将数据文件转换成由0、1组成的二进制串，称之为编码。

等长编码方案、不等长编码方案1、不等长编码方案2

> 案例5.2：利用二叉树求解表达式的值

一般情况下，一个表达式由一个运算符和两个操作数构成，两个操作数之间有次序之分，并且操作数本身也可以是表达式，这个结构类似于二叉树，因此可以利用二叉树来表示表达式。

## 5.3 树和二叉树的抽象数据类型定义

根据树的结构定义，加上树的一组基本操作就构成了树的抽象数据类型定义。

    ADT BinaryTree{
        // 数据对象D：
        // 数据关系R：
        // 基本操作P：
    }ADT BinaryTree;

## 5.4 二叉树的性质和存储结构

### 5.4.1 二叉树的性质

性质1：在二叉树的第i层上至多有2^(i-1)个结点(i≥1)

性质2：深度为k的二叉树一共至多有2^k-1 个结点(k≥1)

性质3：对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2+1。即叶子结点的数目等于度为2的结点数为n2，再加1。

> 两种特殊形式的二叉树

1. 满二叉树

    满二叉树：深度为k且含有2^k-1个结点的二叉树。

    特点：

    - 每一层上的结点数都是最大结点数（即每层都满）

    - 叶子节点全部在最底层。

    对满二叉树结点位置进行编号，按照从根结点开始，自**上而下，自左而右**进行编号，可以发现每一结点位置都有元素。

    满二叉树在同样深度的二叉树中**结点个数最多**。

    满二叉树在同样深度的二叉树中**叶子结点个数最多**。

2. 完全二叉树

    完全二叉树：深度为k的，有n个结点的二叉树，当且仅当其**每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时**，称之为完全二叉树。

    同理，在满二叉树中，从最后一个结点开始，**连续去掉任意**个结点，即是一棵完全二叉树。

    完全二叉树的特点是：

    - 叶子结点只可能在层次最大的两层上出现；

    - 对任一结点，若其右分支下的子孙(即右子树)的最大层次为i，则其左分支下的子孙(左子树)的最大层次必为i或i+1。

性质4：具有n个结点的完全二叉树的深度为⌊log2n⌋ + 1。

性质5：如果对一棵有n个结点的完全二叉树(其深度为⌊log2n⌋+ 1)的结点按层序编号(从第1层到第⌊log2n⌋+1层，每层从左到右)，则对任一结点i(1≤i≤n)，有：

1. 如果i=1，则结点1是二叉树的根，无双亲；如果i>1，则其双亲是结点⌊i/2⌋。

2. 如果2i>n，则结点i无左孩子(结点i为叶子结点)；否则其左孩子是结点2i。

3. 如果2i+1>n，则结点无右孩子；否则其右孩子是结点2i+1。

性质5表明了完全二叉树中**双亲结点编号与孩子结点编号**之间的关系。

### 5.4.2 二叉树的存储结构

二叉树的存储结构主要有顺序存储结构和链式存储结构，其中链式存储结构又分为二叉链表和三叉链表。

二叉树的顺序存储实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素。

    ```C++
        // 二叉树顺序存储表示
        #define MAXSIZE 100
        Typedef TElemType SqBiTree[MAXSIZE];
        SqBiTree bt;
    ```

二叉树的顺序存储缺点：存储密度低，适合存储满二叉树和完全二叉树。

> 二叉树的链式存储结构

    ```C++
        typedef struct BiNode{
            TElemType data;
            BiNode *lchild, *rchild;
        }BiNode, *BiTree;
    ```

在n个结点的二叉表中，有n+1个空指针域。

三叉链表即在二叉链表的基础上增加一个指向父节点的指针。

    ```C++
        typedef struct TriNode{
            TElemType data;
            TriNode *lchild, *parent, *rchild;
        }TriNode, *TriTree;
    ```

## 5.5 遍历二叉树和线索二叉树

### 5.5.1 遍历二叉树

- 遍历定义：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次（又称周游）。

- 遍历目的：得到树中所有结点的一个线性排列。

- 遍历用途：它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。

- 遍历方法：规定在先左后右的情况下，主要遍历方法有三种：先序遍历、中序遍历、后续遍历。

1. 三种遍历方法描述如下：

    ![遍历方法描述](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB.png)

    1. 先序遍历

        访问步骤，若二叉树为空，则空操作；否则：

        1. 访问根节点；

        2. 先续遍历左子树；

        3. 先续遍历右子树。

    2. 中序遍历

        访问步骤，若二叉树为空，则空操作；否则：

        1. 中序遍历左子树；

        2. 访问根结点；

        3. 中序遍历右子树。

    3. 后续遍历

        访问步骤，若二叉树为空，则空操作；否则：

        1. 后续遍历左子树；

        2. 后续遍历右子树；

        3. 访问根结点。

2. 根据遍历顺序确定二叉树

    - 若二叉树中各结点的值均不同，则二叉树结点的先序序列、中序序列、后序列都是唯一的。

    - 由二叉树的先序序列和中序序列，或由二叉树的后序序列和中序序列可以确定唯一一棵二叉树

    例题：已知二叉树的先序和中序序列，构造出相应的二叉树：**可以先由先序序列确定根，由中序确定左右子树**。

    已知中序序列和后序序列，**由后序遍历可知，根结点必在后续序列尾部**。

3. 遍历的算法实现——先序遍历

    二叉树先续遍历算法（递归）

        ```C++
            status PreOrderTraverse(BiTree T){
                if(T == NULL) return OK;    // 空二叉树
                else{
                    visit(T);// 访问根结点
                    PreOrderTraverse(T->lchild);    // 递归遍历左子树
                    PreOrderTraverse(T->rchild); // 递归遍历右子树
                }
            }
        ```

4. 遍历算法实现——中序遍历

    二叉树中序遍历算法（递归）

        ```C++
            status InOrderTraverse(BiTree T){
                if(T == NULL) return OK;    // 空二叉树
                else{
                    InOrderTraverse(T->lchild);    // 递归遍历左子树
                    visit(T);// 访问根结点
                    InOrderTraverse(T->rchild); // 递归遍历右子树
                }
            }
        ```
5. 遍历算法实现——后序遍历

    二叉树后序遍历算法（递归）

        ```C++
            status PostOrderTraverse(BiTree T){
                if(T == NULL) return OK;    // 空二叉树
                else{
                    PostOrderTraverse(T->lchild);    // 递归遍历左子树
                    PostOrderTraverse(T->rchild); // 递归遍历右子树
                    visit(T);// 访问根结点
                }
            }
        ```

6. 遍历算法分析

    - 如果去掉输出语句，从递归的角度看，三种算法是完全相同的，或说这三种算法的访问路径是相同的，只是访问结点的时机不同。

    - 时间效率：O(n)；每个结点只访问一次

    - 空间效率：O(n)；栈占用的最大辅助空间

7. 遍历二叉树的非递归算法

    中序遍历非递归算法：二叉树中序遍历的非递归算法的关键在于：**在中序遍历过某节点的整个左子树后，如何找到该接点的根以及右子树**。

    基本思想：

    - 建立一个空栈S，指针p指向根结点

    - 申请一个结点空间q，用来存放栈顶弹出的元素。

    - 当p非空或者栈S非空时，循环执行以下操作：

        - 如果p非空，则将p进栈，p指向该结点的左孩子；

        - 如果p为空，则弹出栈顶元素并访问，将p指向该结点的右孩子。

    中序遍历非递归算法实现：

        ```C++
            Status InOrderTraverse(BiTree T){
                BiTree p; InitStack(S); p = T;
                while(p || !StackEmpty(S)){
                    if(p){ // 不为空
                        Push(S, p);
                        p = p->lchild;
                    }
                    else{
                        Pop(S, q);
                        print("%c", q->data);
                        p = q->rchild;
                    }
                }
                return OK;
            }
        ```

    无论是递归还是非递归遍历二叉树，因为每个结点被访问一次，则不论按哪一种次序进行遍历，对含n个结点的二叉树，其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量，即树的深度，最坏情况下为n，则空间复杂度也为O(n)。

8. 二叉树的层次遍历

    对于一颗二叉树，从根结点开始，按**从上到下、从左到右**的顺序访问每一个结点。每一个结点仅仅访问一次。

    算法思路：

    - 将根结点入队；

    - 队不为空时循环：从队列中出列一个结点*p，访问它：

        - 若它右左孩子结点，将左孩子结点入队；

        - 若它有右孩子结点，将右孩子结点入队。

    二叉树层次遍历算法实现：

        ```C++
            typedef struct{
                BTNode data[MaxSize];   // 存放队中元素
                int front, rear;        // 队头和队尾指针
            }SqQueue;   // 顺序循环队列类型

            void LevelOrder(BTNode *b){
                BTNode* p;
                SqQueue* qu;
                InitQueue(sqQueue); // 初始化队列
                enQueue(qu, b);     // 根结点指针入队
                while(!QueueEmpty(qu)){
                    // 队不为空，则循环
                    deQueue(qu, p); // 出队结点p
                    cout << p->data;
                    if(p->lchild != NULL){
                        // 有左孩子时将其入队
                        enQueue(qu, p->lchild);
                    }
                    if(p->rchild != NULL){
                        // 有右孩子时将其入队
                        enQueue(qi, p->rchild);
                    }
                }
            }
        ```

9. 二叉树遍历算法的应用——二叉树的建立(算法5.3)

    按照先续遍历序列建立二叉树的二叉链表

    算法步骤：

    - 扫描字符序列，读入字符，建立二叉树的存储结构；

    - 如果ch是一个"#"字符，则表明该二叉树为空树，即T为NULL；否则执行以下操作：在建立二叉树的过程中按照二叉树先序方式建立：

      - 申请一个结点空间T；

      - 将ch赋给T->data；

      - 递归创建T的左子树

      - 递归创建T的右子树

    算法实现：

        ```C++
            void CreateBiTree(BiTree& T){
                // 按先序次序输入二叉树中结点的值（一个字符），创建二叉链表表示的二叉树T
                cin >> ch;
                if(ch == "#") T = NULL; // 递归结束，建空树
                else{
                    // 递归创建二叉树
                    T = new BiTree; // 生成根结点
                    T->data = ch;   // 根结点数据域置为ch
                    CreateBiTree(T->lchild);// 递归创建左子树
                    CreateBiTree(T->rchild);// 递归创建右子树
                }
            }
        ```

10. 二叉树遍历算法的应用——复制二叉树(算法5.4)

    算法步骤：

    如果是空树，递归结束，否则执行以下操作：

    - 申请一个新结点空间， 复制根结点；

    - 递归复制左子树；

    - 递归复制右子树。

    算法实现：

        ```C++
            void Copy(BiTree T, BiTree& NewT){
                // 复制一棵和T完全相同的二叉树
                if(T == NULL){
                    // 如果是空树，递归结束
                    newT = NULL;
                    return;
                }
                else{
                    newT = new BoTree;
                    newT->data = T->data;// 复制根结点
                    Copy(T->lchild, newT->lchild);// 递归复制左子树
                    Copy(T->rchild, newT->rchild);// 递归复制左子树
                }
            }
        ```

11. 二叉树遍历算法的应用——计算二叉树的深度(算法5.5)

    如果是空树，递归结束，深度为0，否则执行以下操作：

    - 递归计算左子树的深度记为m；

    - 递归计算右子树的深度记为n;

    - 如果m大于n，二叉树的深度为m+1，否则为n+1。

    算法实现：

        ```C++
            int Depth(BiTree T){
                // 计算二叉树T的深度
                if(T == NULL) return 0;
                else{
                    m = Depth(T->lchild);   // 递归计算左子树的深度记为m
                    n = Depth(T->rchild);   // 递归计算右子树的深度记为n
                    if(m > n) return(m+1);  // 二叉树深度为m与n的较大者加1
                    else{
                        return (n+1);
                    }
                }
            }
        ```

    计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。

12. 二叉树遍历算法的应用——统计二叉树结点的个数(算法5.6)

    如果是空树，则结点个数为0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加上1。

    算法实现：

        ```C++
            int NodeCount(BiTree T){
                if(T == NULL) return 0;
                else{
                    return NodeCount(T->lchild) + NodeCount(T->rchild) + 1;
                }
            }
        ```

13. 二叉树遍历算法的应用——统计二叉树叶子结点的个数(补充算法)

    如果是空树，则结点个数为0；否则，结点个数为左子树的叶子结点个数加上右子树的叶子结点个数再加上1。

    算法实现：

        ```C++
            int LeafCount(BiTree T){
                if(T == NULL) return 0;
                if(T->lchild == NULL && T->rchild == NULL) 
                {
                    // 如果是叶子节点返回1
                    return 1;
                }
                else{
                    return LeafCount(T->lchild) + LeafCount(T->rchild);
                }
            }
        ```

### 5.5.2 线索二叉树

1. 线索二叉树的基本概念

    遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树中结点的先序序列、中序序列或后序序列。

    但是，当以二叉链表作为存储结构时，只能找到结点的左、右孩子信息，而不能直接得到结点**在任一序列中的前驱和后继信息**，这种信息只有在遍历的动态过程中才能得到，为此**引入线索二叉树来保存这些在动态过程中得到的（任一序列中的）有关前驱和后继的信息**。

    由于有n个结点的二叉链表中必定存在n+1个空链域，因此可以充分利用这些空链域来存放结点的前驱和后继信息。可做如下规定：若结点有左子树，则其lchild域指示其左孩子，**否则令lchild域指示其前驱**；若结点有右子树，则其rchild域指示其右孩子，**否则令rchild域指示其后继**。同时，为了避免混淆，尚需改变结点结构，增加两个标志域：LTag和RTag，其中标志位为0表示存储的为左/右孩子，为1表示存储的为前驱/后继。

    这种改变指向的指针称为“线索”，加上了线索的二叉树称为线索二叉树(Threaded Binary Tree)，对二叉树按某种遍历次序使其变为线索二叉树的过程叫**线索化**。

        ```C++
            // 二叉树的二叉线索存储表示
            typedef struct BiThrNode
            {
                TElemType data;
                BiThrNode *lchild, *rchild;
                int LTag, RTag;
            }BiThrNode, *BiThrTree;
        ```

    以下为先序线索二叉树、中序线索二叉树、后序线索二叉树示意图。

    ![先序线索二叉树](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png)

    ![中序线索二叉树]()

    ![后序线索二叉树](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png)

    为了方便起见，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其**lchild域的指针指向二叉树的根结点**，其**rchild域的指针指向遍历遍历时访问的最后一个结点**；同时，**令二叉树遍历序列中第一个结点的lchild域指针和最后一个结点rchild域的指针均指向头结点**。这好比为二叉树建立了一个双向线索链表，既可从第一个结点起顺后继进行遍历，也可从最后一个结点起顺前驱进行遍历。

    即其中LTag = 0，lchild指向根结点；RTag = 1，rchild指向遍历序列中最后一个结点。

2. 构造线索二叉树

    TODO

## 5.6 树和森林

树(Tree)是n(n≥0)个结点的有限集。若n=0，称为空树。

若n>0，当有且仅有一个特定的称为根(root)的结点；其余结点可分为m(m≥0)个互不相交的有限集T1，T2，T3，...，Tm

森林是m(m≥0)个互不相交的树的集合。

### 5.6.1 树的存储结构

1. 双亲表示法

    这种表示方法中，以一组连续的存储单元存储树的结点，每个结点除了数据域data外，还附设一个parent域用以指示其双亲结点的位置。

    ![树的双亲表示法](https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter5%20TreeAndBianryTree/%E6%A0%91%E7%9A%84%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png)

    双亲表示法特点：找双亲结点容易，找孩子结点难。

    类型描述：

        ```C++
            struct PTNode{
                TElemType data;
                int parent; // parent结点位置
            };

            #define MAX_TREE_SIZE 100
            struct PTree{
                PTNode nodes[MAX_TREE_SIZE];
                int r, n;   // 根结点的位置和节点个数
            };
        ```

2. 孩子表示法
