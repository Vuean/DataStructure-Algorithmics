# 第7章 查找

## 7.1 查找的基本概念

**查找表**是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着**松散的关系**，因此查找表是一种应用灵便的结构。

**查找**：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素或（记录）

- **关键字**：用来标识一个数据元素（或记录）的某个数据项的值

    - **主关键字**：可唯一地标识一个记录的关键字是主关键字；

    - **次关键字**：反之，用以识别若干记录的关键字是次关键字。

1. 查找的目的：

   - 查询某个“特定的"数据元素是否在查找表中；

   - 检索某个“特定的“数据元素的各种属性；

   - 在查找表中插入一个数据元素；

   - 删除查找表中的某个数据元素。

2. 查找的分类

    - **静态查找表**：仅作“查询”（检索）操作的查找表

    - **动态查找表**：作“插入”和“删除”操作的查找表

3. 如何评价查找算法

    - 查找算法的评价指标“：关键字的平均比较次数，也称为**平均查找长度**，（ASL, Average Search Length）。

    !(平均查找长度定义)[https://github.com/Vuean/DataStructure-Algorithmics/blob/main/Chapter7%20Search/%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6%E5%AE%9A%E4%B9%89.png]

查找的方法取决于查找表的结构，即表中数据元素是依何种关系组织在一起的。

由于对查找表来说，在集合中查询或检索一个“特定的”数据元素时，若无规律可循，只能对集合中的元素一一加以辨认直至找到为止。而这样的“查询”或“检索”是任何计算机应用系统中使用频度都很高的操作，因此设法提高查找表的查找效率，是本章讨论问题的出发点。

为提高查找效率，一个办法就是在构造查找表时，在集合中的数据元素之间人为地加上某种确定的约束关系。

## 7.2 线性表的查找

### 7.2.1 顺序查找（线性查找）

应用范围：顺序表或线性链表表示的**静态查找表**；表内元素之间无序

```C++
    int Search_Seq(SSTable ST, KeyTable key)
    {
        // 若成功返回其位置信息，否则返回0
        for(i = ST.length; i >= 1; i--)
        {
            if(ST.R[i].key == key) return i;
        }
        return 0;
    }
```

改进：把待查关键字key存入表头（“哨兵”、”监视哨”），从后往前逐个比较，可免去查找过程中每一步都要检测是否查找完毕，加快速度。

```C++
    int Search_Seq(SSTable ST, KeyTable key)
    {
        ST.R[0].key = key;
        for(i = ST.length; ST.R[i].key != key; i--);
        return i;
    }
```

当ST.length较大时，此改进能使进行一次查找所需的平均时间几乎减少一半。

- 时间复杂度：O(n)，查找成功时的平均查找长度为：`ASL(n) = (1+2+...+n)/n = (n+1)/2`。

- 空间复杂度：一个辅助空间，O(1)。

讨论：

1. 记录的查找概率不相等时如何提高查找效率？

    查找表存储记录原则按查找概率高低存储：

    1. 查找概率越高，比较次数越少；

    2. 查找概率越低，比较次数较多。

2. 记录的查找概率无法测定时如何提高查找效率？

    方法——按查找概率**动态调整**记录顺序：
    1. 在每个记录中设一个访问频度域；
    
    2. 始终保持记录按非递增有序的次序排列；
    
    3. 每次查找后均将刚查到的记录直接移至表头。

优点：算法简单，逻辑次序无要求，且不同存储结构均适用。

缺点：ASL太长，时间效率太低

### 7.2.2 折半查找（二分或对分查找）

**折半查找**：每次将待查记录所在区间缩小一半。

- 折半查找算法：（非递归算法）

    - 设表长为n，low、high和mid分别指向待查元素所在区间的上界、下界和中点，key为给定的要查找的值；

    - 初始时，令low=1，high=n，mid=floar((low+high)/2)

    - 让k与mid指向的记录比较

        - 若key==R[mid].key，查找成功；
        - 若key<R[mid].key，high=mid-1；
        - 若key>R[mid].key，low=mid+1；

    - 重复上述操作，直至low>high时，查找失败

```C++
    int Search_Bin(SSTable ST, KeyTable key)
    {
        low = 1; high = ST.length;
        while(low <= high)
        {
            mid = (low + high) / 2;
            if(ST.R[mid].key == key) return mid;
            else if(key < ST.R[mid].key)
                high = mid-1;
            else
                low = mid + 1;
        }
        return 0;
    }
```

递归版：

```C++
    int Search_Bin(SSTable ST, KeyTable key, int low, int high)
    {
        if(low > high) return 0;
        mid = (low + high) / 2;
        if(key == ST.elem[mid].key) return mid;
        else if(key < ST.elem[mid].key)
            Search_Bin(ST,key, mid-1, high);
        else
            Search_Bin(ST,key, low, mid+1);
    }
```

假定每个元素的查找概率相等，查找成功时的平均查找长度（ASL），设表长n=2^h-1，则h=log2(n+1)，查找概率相等为：1/n，`ASL≈log2(n+1)-1    (n>50)`。

优点：效率比顺序查找高

缺点：只适用于**有序表**，且限于**顺序存储结构**（对线性链表无效）。

### 7.2.3 分块查找（索引顺序查找）

分块查找条件基础：

1. 将表分成几块，且表有序或者分块有序。若i < j，则第j块中所有记录的关键字均大于第i块中的最大关键字。

2. 建立”索引表“（每个结点含有最大关键字域和指向本块第一个结点的指针，且按关键字有序）。

查找过程：先确定待查记录所在块（顺序或折半查找），再在块内查找（顺序查找）。

查找效率：ASL = LB + LW；即对索引表查找的ASL加上对块内查找的ASL

![分块查找效率]()

优点：插入和删除较容易，无需进行大量移动

缺点：要增加一个索引表的存储空间并对初始索引表进行排序运算

适用情况：如果线性表既要**快速查找**又经常**动态变化**，则可采用分块查找。

![查找方法比较]()

## 7.3 树表的查找

