# 第二章 线性表

## 2.1 线性表的定义和特点

**线性表是具有相同特性的数据元素的一个有限序列**。

> 线性表(Linear List)：

由n(n ≥ 0)个数据元素（结点）a1, a2, ... an组成的**有限序列**。

- 其中数据元素的个数n定义为表的**长度**

- 当n=0时称为**空表**

- 将非空的线性表(n>0)记作：(a1, az, ... an)

- 这里的数据元素ai(1≤i≤n)只是一个抽象的符号，其具体含义在不同的情况下可以不同。

> 线性表的逻辑特征

- 在非空的线性表，有且仅有一个开始结点a1，它没有直接前趋，而仅有一个直接后继a2；

- 有且仅有一个终端结点an，它没有直接后继，而仅有一个直接前趋an-1；

- 其余的内部结点ai(2≤i≤n-1)都有且仅有一个直接前趋ai-1和一个直接后继ai+1。

## 2.2 案例引入

> 顺序存储结构存在问题

- 存储空询分配不灵活

- 运算的空间复杂度高

> 总结

- 线性表中的数据元素的类型可以为**简单类型**，也可以为**复杂类型**

- 许多实际应用问题所涉的基本操作有很大相似性，不应为每个具体应用单独编写一个程序

- 从具体应用中抽象出共性的**逻辑结构和基本操作**（抽象数据类型），然后实现其**存储结构和基本操作**

## 2.3 线性表的定义

> 基本操作

- InitList(&L)

  - 操作结果：构造一个空的线性表L

- DestoryList(&L)

  - 初始条件：线性表L已存在

  - 操作结果：销毁线性表L

- ClearList(&L)

  - 初始条件：线性表L已存在

  - 操作结果：将线性表L重置为空表

- ListEmpty(L)

  - 初始条件：线性表L已存在

  - 操作结果：若线性表L空表则返回TURE；否则返回FALSE。

- ListLength(L)

  - 初始条件：线性表L已存在

  - 操作结果：返回线性表L中的数据元素个数。

- GetElem(L, i, &e)

  - 初始条件：线性表L已存在，1 <= i <= ListLength(L)

  - 操作结果：用e返回线性表L中第个数据元素的值。

- LocateElem(L, e, compare())

  - 初始条件：线性表L已存在，compare()是数据元素判定函数

  - 操作结果：返回L中第1个与e满足compare()的数据元素的位序。若这样的数据元素不存在则返回值为0。

- PriorElem(L, cur_e, &pre_e)

  - 初始条件：线性表L已存在

  - 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，否则操作失败；pre_e无意义。

- NextElem(L, cur_e, &next_e)

  - 初始条件：线性表L已存在

  - 操作结果：若cur_e是L的数据元素，且不是第最后个，则用next_e返回它的后继，否则操作失败，next_e无意义。

- ListInsert(&L, i, e)

  - 初始条件：线性表L已存在，1 <= i <= ListLength(L)+1

  - 操作结果：在L的第i个位置**之前**插入新的数据元素e，L的长度加一。

- ListDelete(&L, i, &e)

  - 初始条件：线性表L已存在，1 <= i <= ListLength(L)

  - 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减一。

- ListTraverse(&L, visited())   // 遍历

  - 初始条件：线性表L已存在

  - 操作结果：依次对线性表中每个元素调用visited()。

## 2.4 线性表的顺序表示和实现

### 2.4.1 线性表的顺序存储表示

线性表的顺序表示又称为**顺序存储结构**或**顺序映像**。

顺序存储定义：把**逻辑上相邻的数据元素**存储在**物理上相邻的存储单元**中的存储结构。

线形表顺序存储结构占用**一片续的存储空间**。知道某个元素的存储位置就可以计算其他元素的存储位置。

> 数组静态分配

```C++
  typedef struct{
    ElemType data[MaxSize];
    int length;
  } SqList; // 顺序表类型
```

数组存放的是第一个元素的地址，因此也可以写成以下动态分配形式，用指针代替第一个元素地址。

> 数组动态分配

```C++
  typedef struct{
    ElemType *data;
    int length;
  } SqList; // 顺序表类型
```

```C++
  SqList L;
  L.data = (ElemType*)malloc(sizeof(ElemType) * MaxSize);
```

在头文件stdlib.h中：

malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址。

free(p)函数，释放指针p所指变量的存储空间，即彻底删除一个变量。

## 2.4.2 顺序表基本操作的实现

> 线性表L的初始化

```C++
  Status InitList_Sq(SqList&L){// 构造一个空的顺序表L   
  L.elem=new ElemType[MAXSIZE]; // 为顺序表分配空间
  if(!L.elem) exit(OVERFLOW); // 存储分配失败
  L.length = 0; // 空表长度为0
  return OK；
```

> 销毁线性表L

```C++
  void DestoryList(SqList &L)
  {
    if(L.elem) delete L.elem; // 释放存储空间
  }
```

> 清空线性表L

```C++
  void ClearList(SqList &L){
    L.length = 0; // 将线性表的长度置为0
  }
```

> 求线性表的长度

```C++
  int GetLength(SqList &L){
    return L.length;
  }
```

> 判断线性表是否为空

```C++
  int IsEmpty(SqList &L){
    if(L.length == 0) return 0;
    return 1;
  }
```

> 顺序表的取值

```C++
  // 取物理位置第i个元素
  int GetElem(SqList L, int i, ElemType &e){
    if(i < 1 || i >= L.length) return ERROR;

    e = L.elem[i-1];
    return OK;
  }
```

> 顺序表按值查找(顺序查找)

- 在线性表L中查找与指定值e相同的数据元素的位置

- 从表的一端开始，逐个进行记录的关键字和给定值的比较。找到，返回该元素的位置序号，未找到，返回0。

平均查找长度ASL(Average Search Length):

- 为确定记录在表中的位置，需要与给定值进行比较的关键字的个数的期望值叫做查找算法的**平均查找长度**。

> 顺序表插入

插入不同位置的算法演示：插入位置在最后、插入位置在中间、插入位置在最前面

算法思想：

1. 判断插入位置i是否合理

2. 判断顺序表的存储空间是否已满，若已满返回ERROR

3. 将第n至第i位的元素一次向后移动一个位置，空出第i个位置

4. 将要插入的新元素e放入第i个位置

5. 表长加1，返回插入成功。

```C++
  ListInsert_Sq(SqList& L, int i, ElemType e)
  {
    if(i < 1 || i > L.length+1) return ERROR; // i值不合法
    if(L.length == MAXSIZE) return ERROR; // 当前存储已满
    for(j = L.length-1; j >= i; j--){
      L.elem[j+1] = L.elem[j];
    }
    L.elem[i-1] = e;
    L.length++;
    return OK;
  }
```

顺序表插入算法的平均时间复杂度为O(n)。

> 顺序表的删除算法

算法思想：

1. 判断删除位置i是否合法

2. 将欲删除的元素保留在e中

3. 将第i+1至第n位的元素依次向前移动一个位置

4. 表长减1，删除成功返回OK

```C++
  ListInsert_Sq(SqList& L, int i, ElemType &e)
  {
    if(i < 1 || i > L.length+1) return ERROR; // i值不合法
    e = L.elem[i];
    for(j = i; j <= L.length-1; j++){
      L.elem[j-1] = L.elem[j];
    }
    L.length--;
    return OK;
  }
```

顺序表删除算法的平均时间复杂度为O(n)。

## 2.4.3 顺序表小结

1. 利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与存储结构一致

2. 在访问线性表时，可以快速地计算出任何一个数据元素的存储地址。因此可以粗略地认为，访问每个元素所花时间相等

   - 这种存取元素的方法被称为随机存取法

> 顺序表的操作算法分析

- 时间复杂度

  - 查找、插入、删除算法的平均时间复杂度为O(n)

- 空间复杂度

  - 顺序表操作算法的空间复杂度S(n) = O(1)，没有占用辅助空间

> 顺序表的优缺点

1. 优点

   - 存储密度大（结点本身所占存储量/结点结构所占存储量）
  
   - 可以随机存取表中任一元素

2. 缺点

   - 在插入、删除某一元素时，需要移动大量元素

   - 浪费存储空间

   - 属于静态存储形式，数据元素的个数不能自由扩充

## 2.5 线性表的链式表示和实现

## 2.6 顺序表和链式表的比较

## 2.7 线性表的应用

## 2.8 案例分析与实现
