# 第6章 图

图是一种比线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每一层中的数据元素可能和下一层中的多个元素（即其孩子结点）相关，但只能和上一层中一个元素（即其双亲结点）相关；而在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。在数据结构中，应用图论的知识讨论如何在计算机上实现图的操作，因此主要学习图的存储结构，以及若于图的操作的实现。

## 6.1 图的定义和基本术语

### 6.1.1 图的定义

图(Graph)G由两个集合V和E组成，记为G=(V,E)：

- V(vertex)是顶点的**有穷非空集合**;

- E(Edge)是V中顶点偶对的**有穷集合**，这些顶点偶对称为**边**。

V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。

对于图G，若边集E(G)为有向边的集合，则称该图为有向图；若边集E(G)为无向边的集合，则称该图为无向图。

对于图G，若图中任意两个点之间都有一条边相连，则称为**完全图**。对于n个顶点，则无向完全图有n(n-1)/2条边，有向完全图有n(n-1)条边。

### 6.1.2 图的基本术语

用n表示图中顶点数目，用e表示边的数目，下面介绍图结构中的一些基本术语。

1. **无向完全图**和**有向完全图**：对于无向图，若具有n(n- 1)/2条边，则称为无向完全图。对于有向图，若具有n(n-1)条弧，则称为有向完全图。

2. **稀疏图**和**稠密图**：有很少条边或弧(如e < nlogn)的图称为稀疏图，反之称为稠密图。

3. **权**和**网**：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。**这种带权的图通常称为网**。

4. **邻接**：描述图中两个顶点之间的关系，有边/弧相连的两个顶点，称为两顶点邻接。

5. **邻接点**：对于无向图G，如果图的边(v, v')∈E，则称顶点v和v'互为邻接点，即v和v'相邻接。边(v, v')**依附于**顶点v和v'，或者说边(v, v')与顶点v和v'**相关联**。在有向图中，存在`<v, v'>`，则称**v邻接到v'，v'邻接于v**。

6. **度**、**入度**和**出度**：顶点的度是指和v**相关联的边的数目**，记为TD(v)。对于有向图，顶点v的度分为入度和出度。入度是以顶点v为头的弧的数目，记为ID(v)；出度是以顶点v为尾的弧的数目，记为OD(v),顶点v的度为TD(v) = ID(v) + OD(v)。

7. **路径**和**路径长度**：接续的边构成的顶点序列。在无向图G中，从顶点v到顶点v'的路径是一个顶点序列。如果G是有向图，则路径也是有向的。路径长度是一条路径上经过的边或弧的数目或权值之和。

8. **回路**或**环**：第一个顶点和最后一个顶点相同的路径称为回路或环。

9. **简单路径**、**简单回路**或**简单环**：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

10. **连通**、**连通图**和**连通分量**：在无向图G中，如果从顶点v到顶点v'有路径，则称v和v'是连通的。如果对于图中任意两个顶点Vi、Vj，Vi和Vj都是连通的，则称G是连通图。所谓连通分量，指的是无向图中的极大连通子图。其中极大连通子图意思是：**该子图是连通子图，将G的任何不在该子图中的顶点加入，子图不再连通**。

11. **强连通图**和**强连通分量**：在有向图G中，如果对于每一对Vi, Vj，从Vi到Vj和从Vj到Vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。

12. 极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边，该子图不再连通。

13. **连通图的生成树**：包含无向图G所有顶点的极小连通图；一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边，这样的连通子图称为连通图的生成树。

14. **有向树**和**生成森林**：有一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树。一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

## 6.2 案例引入

## 6.3 图的类型定义

图是一种数据结构，加上一组基本操作，就构成了抽象数据类型。抽象数据类型图的定义如下：

```C++
    ADTGraph{
        数据对象： V是具有相同特性的数据元素的集合，称为顶点集。
    数据关系：
        R = {VR}
        VR = {<v, w>|v, w属于V，且P(v, w) <v, w>表示从v到w的弧，谓词P(v, w)定义了弧<v, w>的意义或信息}
    基本操作：
        图的创建、增删改查等。其中重要的包括有构造图、深度优先搜索、广度优先搜索。
```

## 6.4 图的存储结构

由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序存储结构，但**可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法（数组表示法）**。另一方面，由于图的任意两个顶点间都可能存在关系，因此，用链式存储表示图是很自然的事，图的链式存储有多种，有**邻接表**、**十字链表**和**邻接多重表**，应根据实际需要的不同选择不同的存储结构。

### 6.4.1 邻接矩阵

1. 邻接矩阵表示法

    建立一个**顶点表**(记录哥各个顶点信息)和一个**邻接矩阵**(表示各个顶点之间关系)。

    **邻接矩阵**(**Adjacency Matrix**)是表示顶点之间相邻关系的矩阵。设G(V, E)是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵：

    ```C++
        A[i][j] = 1; 若<i, j>∈E或者(i, j)∈E
        A[i][j] = 0; 否则
    ```

    - 分析1：无向图的邻接矩阵是对阵的；
    - 分析2：顶点i的度=第i行(列)中的1的个数；
    - 分析3：完全图的邻接矩阵中，对焦元素为0，其余为1。

    有向图的邻接矩阵需考虑边的方向。

    - 分析1：有向图的邻接矩阵可能是不对称的；
    - 分析2：顶点的出度=第i行元素之和，顶点的入度=第i列元素之和，顶点的度=第i行元素之和+第i列元素之和。

    网(即有权图)的邻接矩阵表示法：

    ```C++
        A[i][j] = Wij; 若<vi, vj>或(vi, vj)∈VR
        A[i][j] = ∞; 无边(弧)
        其中，Wij表示边上的权值；∞表示计算机允许的、大于所有边上权值的数。
    ```

    用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。其形式说明如下：

    ```C++
        //-----图的邻接矩阵存储表示－－－－－
        #define MaxInt  32767
        #define MVNum   100         // 最大顶点数
        typedef char VerTexType;    // 设顶点的数据类型为字符型
        typedef int ArcType;        // 假设边的权值类型为整型
        typedef struct
        {
            VerTexType  vexs[MVNum];    // 顶点表
            ArcType     arcs[MVNum][MVNum]; // 邻接矩阵
            int vexnum, arcnum; // 图的当前点数和边数
        }AMGraph;
    ```

2. 采用邻接矩阵表示法创建无向网

    已知一个图的点和边，使用邻接矩阵表示法来创建此图的方法比较简单，下面以一个无向网为例来说明创建图的算法。

    算法步骤：

    1. 输入总顶点数和总边数。
    2. 依次输入点的信息存入顶点表中。
    3. 初始化邻接矩阵，使每个权值初始化为极大值。
    4. 构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。

    算法实现：

    ```C++
        Status CreateUDN(AMGraph &G)
        {
            // 采用邻接矩阵表示法，创建无向网G
            cin >> G.vexnum >> G.arcnum;        // 输入总顶点数，总边数
            for(int i = 0; i < G.vexnum; i++)
            {
                // 依次输入顶点信息
                cin >> G.vexs[i];
            }
            // 初始化邻接矩阵，边的权值均置为极大值MaxInt
            for(int i = 0; i < G.vexnum; i++)
            {
                for(int j = 0; i < G.vexnum; j++)
                {
                    G.arcs[i][j] = MaxInt;
                }
            }
            // 构造邻接矩阵
            for(int k = 0; k < G.arcnum; k++)
            {
                // 输人一条边依附的顶点及权值
                cin >> v1 >> v2 >> w;
                // 确定v1和v2在G中的位置，即顶点数组的下标
                i = LocateVex(G, v1);
                j = LocateVex(G, v2);
                // 边<v1,v2>的权值为w
                G.arcs[i][j] = w;
                G.arcs[j][i] = G.arcs[i][j];
            }
            return OK;
        }

        int LocatVex(AMGraph G, VerTexType u)
        {
            // 图G中查找顶点u，存在则返回顶点表中的下标；否则返回-1
            for(int i = 0; i < G.vexnum; i++)
            {
                if(u == G.vexs[i])
                {
                    return i;
                }
            }
            return -1;
        }
    ```

    该算法的时间复杂度是0(n^2)。

    若要建立无向图，只需对上述算法做两处小的改动：**一是初始化邻接矩阵时，将边的权值均初始化为0；二是构造邻接矩阵时，将权值w改为常量值1即可**。同样，将该算法稍做修改即可建立一个有向网或有向图，即邻接矩阵为非对称矩阵。

3. 邻接矩阵表示法的优缺点

    > 有点

    1. 便于判断两个顶点之间是否有边，即根据A[i][j] = 0或1来判断。

    2. 方便找任意顶点的所有邻接点；

    3. 便于计算各个顶点的度。对于无向图，邻接矩阵第i行元素之和就是顶点i的度；对于有向图，第i行元素之和就是顶点i的出度，第i列元素之和就是顶点i的入度。

    > 缺点

    1. 不便于增加和删除顶点。

    2. 不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n^2)

    3. 空间复杂度高。如果是有向图，n个顶点需要n^2个单元存储边。

        如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要n(n-1)/2个单元即可。

### 6.4.2 邻接表

1. 邻接表表示法

    **邻接表**(**Adjacency List**)是图的一种链式存储结构。在邻接表中，对图中每个顶点vi建立一个单链表，把与vi相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成：**表头结点表**和**边表**。

    1. **表头结点表**：由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的边链表。表头结点包括数据域(data)和链域(firstarc)两部分。其中，数据域用于存储顶点vi的名称或其他有关信息；链域用于指向链表中第一个结点（即与顶点vi邻接的第一个邻接点）。

    2. **边表**：由表示图中顶点间关系的2n个边链表组成。边链表中边结点包括**邻接点域(adjvex)、数据域(info)和链域(nextarc)三部分**。其中，邻接点域指示与顶点vi邻接的点在图中的位置；数据域存储和边相关的信息，如权值等；链域指示与顶点vi邻接的下一条边的结点。

    特点：

    - 邻接表不唯一；
    - 若**无向图**中有n个顶点、e条边，则其邻接表需n个头结点和2e个表结点。适合存储稀疏图；
    - **无向图**中顶点vi的度为第i个单链表中的结点数。
