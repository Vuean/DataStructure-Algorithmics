# 第6章 图

图是一种比线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每一层中的数据元素可能和下一层中的多个元素（即其孩子结点）相关，但只能和上一层中一个元素（即其双亲结点）相关；而在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。在数据结构中，应用图论的知识讨论如何在计算机上实现图的操作，因此主要学习图的存储结构，以及若于图的操作的实现。

## 6.1 图的定义和基本术语

### 6.1.1 图的定义

图(Graph)G由两个集合V和E组成，记为G=(V,E)：

- V(vertex)是顶点的**有穷非空集合**;

- E(Edge)是V中顶点偶对的**有穷集合**，这些顶点偶对称为**边**。

V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。

对于图G，若边集E(G)为有向边的集合，则称该图为有向图；若边集E(G)为无向边的集合，则称该图为无向图。

对于图G，若图中任意两个点之间都有一条边相连，则称为**完全图**。对于n个顶点，则无向完全图有n(n-1)/2条边，有向完全图有n(n-1)条边。

### 6.1.2 图的基本术语

用n表示图中顶点数目，用e表示边的数目，下面介绍图结构中的一些基本术语。

1. **无向完全图**和**有向完全图**：对于无向图，若具有n(n- 1)/2条边，则称为无向完全图。对于有向图，若具有n(n-1)条弧，则称为有向完全图。

2. **稀疏图**和**稠密图**：有很少条边或弧(如e < nlogn)的图称为稀疏图，反之称为稠密图。

3. **权**和**网**：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的权。这些权可以表示从一个顶点到另一个顶点的距离或耗费。**这种带权的图通常称为网**。

4. **邻接**：描述图中两个顶点之间的关系，有边/弧相连的两个顶点，称为两顶点邻接。

5. **邻接点**：对于无向图G，如果图的边(v, v')∈E，则称顶点v和v'互为邻接点，即v和v'相邻接。边(v, v')**依附于**顶点v和v'，或者说边(v, v')与顶点v和v'**相关联**。在有向图中，存在`<v, v'>`，则称**v邻接到v'，v'邻接于v**。

6. **度**、**入度**和**出度**：顶点的度是指和v**相关联的边的数目**，记为TD(v)。对于有向图，顶点v的度分为入度和出度。入度是以顶点v为头的弧的数目，记为ID(v)；出度是以顶点v为尾的弧的数目，记为OD(v),顶点v的度为TD(v) = ID(v) + OD(v)。

7. **路径**和**路径长度**：接续的边构成的顶点序列。在无向图G中，从顶点v到顶点v'的路径是一个顶点序列。如果G是有向图，则路径也是有向的。路径长度是一条路径上经过的边或弧的数目或权值之和。

8. **回路**或**环**：第一个顶点和最后一个顶点相同的路径称为回路或环。

9. **简单路径**、**简单回路**或**简单环**：序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。

10. **连通**、**连通图**和**连通分量**：在无向图G中，如果从顶点v到顶点v'有路径，则称v和v'是连通的。如果对于图中任意两个顶点Vi、Vj，Vi和Vj都是连通的，则称G是连通图。所谓连通分量，指的是无向图中的极大连通子图。其中极大连通子图意思是：**该子图是连通子图，将G的任何不在该子图中的顶点加入，子图不再连通**。

11. **强连通图**和**强连通分量**：在有向图G中，如果对于每一对Vi, Vj，从Vi到Vj和从Vj到Vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。

12. 极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边，该子图不再连通。

13. **连通图的生成树**：包含无向图G所有顶点的极小连通图；一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的n-1条边，这样的连通子图称为连通图的生成树。

14. **有向树**和**生成森林**：有一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树。一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

## 6.2 案例引入

## 6.3 图的类型定义

图是一种数据结构，加上一组基本操作，就构成了抽象数据类型。抽象数据类型图的定义如下：

```C++
    ADTGraph{
        数据对象： V是具有相同特性的数据元素的集合，称为顶点集。
    数据关系：
        R = {VR}
        VR = {<v, w>|v, w属于V，且P(v, w) <v, w>表示从v到w的弧，谓词P(v, w)定义了弧<v, w>的意义或信息}
    基本操作：
        图的创建、增删改查等。其中重要的包括有构造图、深度优先搜索、广度优先搜索。
```

## 6.4 图的存储结构

由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序存储结构，但**可以借助二维数组来表示元素之间的关系，即邻接矩阵表示法（数组表示法）**。另一方面，由于图的任意两个顶点间都可能存在关系，因此，用链式存储表示图是很自然的事，图的链式存储有多种，有**邻接表**、**十字链表**和**邻接多重表**，应根据实际需要的不同选择不同的存储结构。

### 6.4.1 邻接矩阵

1. 邻接矩阵表示法

    建立一个**顶点表**(记录哥各个顶点信息)和一个**邻接矩阵**(表示各个顶点之间关系)。

    **邻接矩阵**(**Adjacency Matrix**)是表示顶点之间相邻关系的矩阵。设G(V, E)是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵：

    ```C++
        A[i][j] = 1; 若<i, j>∈E或者(i, j)∈E
        A[i][j] = 0; 否则
    ```

    - 分析1：无向图的邻接矩阵是对阵的；
    - 分析2：顶点i的度=第i行(列)中的1的个数；
    - 分析3：完全图的邻接矩阵中，对焦元素为0，其余为1。

    有向图的邻接矩阵需考虑边的方向。

    - 分析1：有向图的邻接矩阵可能是不对称的；
    - 分析2：顶点的出度=第i行元素之和，顶点的入度=第i列元素之和，顶点的度=第i行元素之和+第i列元素之和。

    网(即有权图)的邻接矩阵表示法：

    ```C++
        A[i][j] = Wij; 若<vi, vj>或(vi, vj)∈VR
        A[i][j] = ∞; 无边(弧)
        其中，Wij表示边上的权值；∞表示计算机允许的、大于所有边上权值的数。
    ```

    用邻接矩阵表示法表示图，除了一个用于存储邻接矩阵的二维数组外，还需要用一个一维数组来存储顶点信息。其形式说明如下：

    ```C++
        //-----图的邻接矩阵存储表示－－－－－
        #define MaxInt  32767
        #define MVNum   100         // 最大顶点数
        typedef char VerTexType;    // 设顶点的数据类型为字符型
        typedef int ArcType;        // 假设边的权值类型为整型
        typedef struct
        {
            VerTexType  vexs[MVNum];    // 顶点表
            ArcType     arcs[MVNum][MVNum]; // 邻接矩阵
            int vexnum, arcnum; // 图的当前点数和边数
        }AMGraph;
    ```

2. 采用邻接矩阵表示法创建无向网

    已知一个图的点和边，使用邻接矩阵表示法来创建此图的方法比较简单，下面以一个无向网为例来说明创建图的算法。

    算法步骤：

    1. 输入总顶点数和总边数。
    2. 依次输入点的信息存入顶点表中。
    3. 初始化邻接矩阵，使每个权值初始化为极大值。
    4. 构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。

    算法实现：

    ```C++
        Status CreateUDN(AMGraph &G)
        {
            // 采用邻接矩阵表示法，创建无向网G
            cin >> G.vexnum >> G.arcnum;        // 输入总顶点数，总边数
            for(int i = 0; i < G.vexnum; i++)
            {
                // 依次输入顶点信息
                cin >> G.vexs[i];
            }
            // 初始化邻接矩阵，边的权值均置为极大值MaxInt
            for(int i = 0; i < G.vexnum; i++)
            {
                for(int j = 0; i < G.vexnum; j++)
                {
                    G.arcs[i][j] = MaxInt;
                }
            }
            // 构造邻接矩阵
            for(int k = 0; k < G.arcnum; k++)
            {
                // 输人一条边依附的顶点及权值
                cin >> v1 >> v2 >> w;
                // 确定v1和v2在G中的位置，即顶点数组的下标
                i = LocateVex(G, v1);
                j = LocateVex(G, v2);
                // 边<v1,v2>的权值为w
                G.arcs[i][j] = w;
                G.arcs[j][i] = G.arcs[i][j];
            }
            return OK;
        }

        int LocatVex(AMGraph G, VerTexType u)
        {
            // 图G中查找顶点u，存在则返回顶点表中的下标；否则返回-1
            for(int i = 0; i < G.vexnum; i++)
            {
                if(u == G.vexs[i])
                {
                    return i;
                }
            }
            return -1;
        }
    ```

    该算法的时间复杂度是0(n^2)。

    若要建立无向图，只需对上述算法做两处小的改动：**一是初始化邻接矩阵时，将边的权值均初始化为0；二是构造邻接矩阵时，将权值w改为常量值1即可**。同样，将该算法稍做修改即可建立一个有向网或有向图，即邻接矩阵为非对称矩阵。

3. 邻接矩阵表示法的优缺点

    > 优点

    1. 便于判断两个顶点之间是否有边，即根据A[i][j] = 0或1来判断。

    2. 方便找任意顶点的所有邻接点；

    3. 便于计算各个顶点的度。对于无向图，邻接矩阵第i行元素之和就是顶点i的度；对于有向图，第i行元素之和就是顶点i的出度，第i列元素之和就是顶点i的入度。

    > 缺点

    1. 不便于增加和删除顶点。

    2. 不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕，时间复杂度为O(n^2)

    3. 空间复杂度高。如果是有向图，n个顶点需要n^2个单元存储边。

        如果是无向图，因其邻接矩阵是对称的，所以对规模较大的邻接矩阵可以采用压缩存储的方法，仅存储下三角（或上三角）的元素，这样需要n(n-1)/2个单元即可。

### 6.4.2 邻接表

1. 邻接表表示法

    **邻接表**(**Adjacency List**)是图的一种链式存储结构。在邻接表中，对图中每个顶点vi建立一个单链表，把与vi相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息，把这一结点看成链表的表头，其余结点存放有关边的信息，这样邻接表便由两部分组成：**表头结点表**和**边表**。

    1. **表头结点表**：由所有表头结点以顺序结构的形式存储，以便可以随机访问任一顶点的边链表。表头结点包括数据域(data)和链域(firstarc)两部分。其中，数据域用于存储顶点vi的名称或其他有关信息；链域用于指向链表中第一个结点（即与顶点vi邻接的第一个邻接点）。

    2. **边表**：由表示图中顶点间关系的2n个边链表组成。边链表中边结点包括**邻接点域(adjvex)、数据域(info)和链域(nextarc)三部分**。其中，邻接点域指示与顶点vi邻接的点在图中的位置；数据域存储和边相关的信息，如权值等；链域指示与顶点vi邻接的下一条边的结点。

    特点：

    - 邻接表不唯一；
    - 若**无向图**中有n个顶点、e条边，则其邻接表需n个头结点和2e个表结点。适合存储稀疏图；
    - **无向图**中顶点vi的度为第i个单链表中的结点数。

    有向图的邻接表特点：

    - 顶点vi的出度为第i个单链表中的结点个数
    - 顶点vi的入读为整个单链表中邻接点域值是i-1的结点个数。

    反之，逆邻接表记录的是入度，所以找入度易，找出度难。

    **当邻接表的存储结构形成后，图便惟一确定**。

    根据上述讨论，要定义一个邻接表，需要先定义其存放顶点的头结点和表示边的边结点。图的邻接表存储结构说明如下：

    ```C++
        #define MVNum 100           // 最大顶点数
        typedef struct ArcNode      // 边结点
        {
            int adjvex;             // 该边所指向的顶点的位置
            ArcNode* nextarc;       // 指向下一条边的指针
            OtherInfo info;         // 和边相关的信息
        }ArcNode;
        typedef struct VNode        // 顶点信息
        {
            VerTexType data;
            ArcNode *firstarc;      // 指向第一条依附于该顶点的边的指针
        }VNode, AdjList[MVNum];     // AdjList表示邻接表类型
        typedef struct ALGraph
        {
            AdjList vertices;       // 邻接表数组
            int vexnum, arcnum;     // 图的当前定点数和边数
        };
    ```

2. 采用邻接表表示法创建无向图

    算法思想:

    1. 输入总顶点数和总边数。
    2. 依次输入点的信息存入顶点表中，使每个表头结点的指针域初始化为NULL。
    3. 创建邻接表。依次输入每条边依附的两个顶点，确定这两个顶点的序号i和j之后，将此边结点分别插入vi和vj对应的两个边链表的头部。

    > 算法实现

    ```C++
        Status CreateUDG(ALGraph &G)
        {// 采用邻接表表示法，创建无向图G
            cin >> G.vexnum >> G.arcnum;    // 输入总顶点数，总边数
            for(int i = 0; i < G.vexnum; i++)
            {// 输入各点，构造表头结点表
                cin >> G.vertices[i].data;  // 输入顶点值
                G.vertices[i].firstarc = NULL;  // 初始化各表头结点的指针域为NULL
            }
            for(k = 0; k < G.arcnum; k++)
            {// 输入各边，构造邻接表
                cin >> v1 >> v2;
                // 确定v1和v2在G中的位置，即顶点在G.vertices中的序号
                i = LocateVex(G, v1);
                j = LocateVex(G, v2);
                p1 = new ArcNode;   // 生成一个新的边结点
                p1->adjvex = j;     // 邻接点序号为j
                // 将新结点p1插入顶点vi的边表头部
                p1->nextarc = G.vertices[i].firstarc;
                G.vertices[i].firstarc = p1;
                p2 = new ArcNode;   // 生成另一个对称的新的边结点
                p2->adjvex = i;
                // 将新结点p2插入顶点vj的边表头部
                p2->nextarc = G.vertices[j].firstarc;
                G.vertices[j].firstarc = p2;
            }
            return OK;
        }
    ```

    该算法的时间复杂度是O(n + e)。

    建立有向图的邻接表与此类似，只是更加简单，每读入一个顶点对序号<i,j>，仅需生成一个邻接点序号为j的边表结点，并将其插入到vi；的边链表头部即可。若要创建网的邻接表，可以将边的权值存储在info域中。

3. 邻接表表示法的优缺点

    优点：

    1. 便于增加和删除顶点。
    2. 便于统计边的数目，按顶点表顺序扫描所有边表可得到边的数目，时间复杂度为O(n + e)。
    3. 空间效率高。对于一个具有n个顶点e条边的图G，若G是无向图，则在其邻接表表示中有n个顶点表结点和2e个边表结点；若G是有向图，则在它的邻接表表示或逆邻接表表示中均有n个顶点表结点和e个边表结点。因此，邻接表或逆邻接表表示的空间复杂度为O(n + e),适合表示稀疏图。对于稠密图，考虑到邻接表中要附加链域，因此常采取邻接矩阵表示法。

    缺点：

    1. 不便于判断顶点之间是否有边，要判定vi和vj之间是否有边，就需扫描第i个边表，最坏情况下要耗费O(n)时间。
    2. 不便于计算有向图各个顶点的度。对于无向图，在邻接表表示中顶点vi的度是第i个边表中的结点个数。在有向图的邻接表中，第i个边表上的结点个数是顶点vi的出度，但求vi的入度较困难，需遍历各顶点的边表。若有向图采用逆邻接表表示，则与邻接表表示相反，求顶点的入度容易，而求顶点的出度较难。

4. 邻接矩阵与邻接表示法的关系

   1. **联系**：邻接表中每个链表对应邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。

   2. **区别**：

        - 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。

        - 邻接矩阵的空间复杂度为O(n^2)，而领接表的空间复杂度为O(n+e)；

   3. **用途**：邻接矩阵多用于稠密图；而邻接表多用于稀疏图。

### 6.4.3 十字链表

**十字链表**(**Orthogonal List**)是有向图的另一种链式存储结构。我们也可以把它看成是将有向图的邻接表和逆邻接表结合起来形成的一种链表。

**有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点**。

在弧结点中有5个域：其中尾域(tailvex)和头域(headvex)分别指示弧尾和弧头这两个顶点在图中的位置，链域hlink指向弧头相同的下一条弧，而链域tlink指向弧尾相同的下一条弧，info域指向该弧的相关信息。

头结点即顶点结点，它由3个域组成：其中data域存储和顶点相关的信息，如顶点的名称等；firstin和firstout为两个链域，分别指向以该顶点为弧头或弧尾的第一个弧结点。

### 6.4.4 邻接多重表

**邻接多重表**(**Adjacency Multilist**)是无向图的另一种链式存储结构。

邻接多重表的结构和十字链表类似。在邻接多重表中，每一条边用一个结点表示。其中，mark为标志域，可用以标记该条边是否被搜索过；ivex和jvex为该边依附的两个顶点在图中的位置；ilink指向下一条依附于顶点ivex的边；jlink指向下一条依附于顶点jvex的边，info为指向和边相关的各种信息的指针域。

每一个顶点也用一个结点表示，其中，data域存储和该顶点相关的信息，firstedge域指示第一条依附于该顶点的边。

## 6.5 图的遍历

和树的遍历类似，图的遍历也是从图中某一顶点出发，按照某种方法对图中所有顶点访问且仅访问一次。图的遍历算法是求解图的连通性问题、拓扑排序和关键路径等算法的基础。

为避免重复访问，可设置辅助数组visited[n]，用来标记每个被访问过的顶点。

- 初始状态visited[i]为0；
- 顶点i被访问，改visited[i]为1，防止被多次访问

根据搜索路径的方向，通常有两条遍历图的路径：深度优先搜索和广度优先搜索。它们对无向图和有向图都适用。

### 6.5.1 深度优先搜索

1. 深度优先搜索遍历的过程

    **深度优先搜索**(**DepthFirst Search, DFS**)遍历类似于树的先序遍历，是树的先序遍历的推广。对于一个连通图，深度优先搜索遍历的过程如下：

    1. 从图中某个顶点v出发，访问v。

    2. 找出刚访问过的顶点的第一个未被访问的邻接点，访问该顶点。以该顶点为新顶点，重复此步骤，直至刚访问过的顶点没有未被访问的邻接点为止。

    3. 返回前一个访问过的且仍有未被访问的邻接点的顶点，找出该顶点的下一个未被访问的邻接点，访问该顶点。

    4. 重复步骤(2)和(3),直至图中所有顶点都被访问过，搜索结束。

2. 深度优先搜索遍历的算法实现

    显然，深度优先搜索遍历连通图是一个递归的过程。为了在遍历过程中便于区分顶点是否已被访问，需附设访问标志数组visited[n]，其初值为"false，一旦某个顶点被访问，则其相应的分量置为"true"。

    算法6.3 深度优先搜索遍历连通图

    算法步骤：

    1. 从图中某个顶点v出发，访问v，并置visited[v]的值为true。

    2. 依次检查v的所有邻接点w，如果visited[w]的值为false，再从w出发进行递归遍历，直到图中所有顶点都被访问过。

    ```C++
        bool visited[MVNum];
        void DFS(Graph G, int v)
        {
            cout << v;
            visited[v] = true;
            for(w = FitstAdjVex(G, v); w >= 0; w = NextAdjVex(G, v, w))
                if(!visited[w])
                    DFS(G, w);
        }
    ```

    算法6.4 深度优先搜索遍历非连通图

    ```C++
        void DFSTracerse(Graph G)
        {
            for(v = 0; v < G.vexnum; ++v)
            {
                visited[v] = false;
            }
            for(v = 0; v < G.vexnum; ++v)
            {
                if(!visited[v])
                    DFS(G, v);
            }
        }
    ```

    算法6.5 采用邻接矩阵表示图的深度优先搜索遍历

    ```C++
        void DFs(AMGraph G, int v)
        {
            cout << v;
            visited[v] = true;
            for(int w = 0; w < G.vexnum; w++)
            {
                if((G.arcs[v][w] != 0) && (!visited[w]))
                {
                    DFS(G, w);
                }
            }
        }
    ```

    用邻接矩阵来表示图，遍历图中每一个顶点都要从头扫描该顶点所在的行，时间复杂度为O(n^2)。

    算法6.6 采用邻接表表示图的深度优先搜索遍历

    ```C++
        void DFS_AL(ALGraph G, int v)
        {// 图G为邻接表类型，从第v个顶点出发深度优先搜索遍历图G
            cout << v;
            visited[v] = true;
            p = G.vertices[v].firstarc;
            while(p != NULL)
            {
                w = p->adjvex;      // 表示w是v的邻接点
                if(!visited[w])
                    DFS(G,w);
                p = p->nextarc;
            }
        }
    ```

    用邻接表来表示图，虽然有2e个表结点，但只需扫描e个结点即可完成遍历，加上访问个头结点的时间，时间复杂度为O(n+e)。

    因此，**稠密图适于在邻接矩阵上进行深度遍历**，**稀疏图适于在邻接表上进行深度遍历**。

### 6.5.2 广度优先搜索

1. 广度优先搜索遍历的过程

    **广度优先搜索**(**Breadth First Search, BFS**)遍历类似于树的按层次遍历的过程。广度优先搜索遍历的过程如下：

    1. 从图中某个顶点v出发，访问v。

    2. 依次访问v的各个未曾访问过的邻接点。

    3. 分别从这些邻接点出发依次访问它们的邻接点，并使“先被访问的顶点的邻接点”先于“后被访问的顶点的邻接点”被访问。重复步骤(3)，直至图中所有已被访问的顶点的邻接点都被访问到。

2. 广度优先搜索遍历的算法实现

    算法6.7 广度优先搜索遍历连通图

    算法步骤：

    1. 从图中某个顶点v出发，访问v，并置visited[v]的值为true，然后将v进队。

    2. 只要队列不空，则重复下述操作：

        - 队头顶点u出队；

        - 依次检查u的所有邻接点w，如果visited[w]的值为false，则访问w，并置visited[w]的值为true，然后将w进队。

    算法描述：

    ```C++
        void BFS(Graph G, int v)
        {
            cout << v;
            visited[v] = true;
            InitQueue(Q);
            EnQueue(Q, v);  //v入队
            while(!QueueEmpty(Q))
            {
                DeQueue(Q, u);  // 队首元素出队并置为u
                for(w = FirstAdjVex(G, u); w >= 0; NextAdjVex(G, u, w))
                {
                    if(!visited[w])
                    {
                        cout << w;
                        visited[w] = true;
                        EnQueue(Q, w);
                    }
                }
            }
        }
    ```

    遍历图的过程实质上是通过边找邻接点的过程，因此广度优先搜索遍历图的时间复杂度和深度优先搜索遍历相同，即当用邻接矩阵存储时，时间复杂度为O(n^2)；用邻接表存储时，时间复杂度为O(n+e)。

### 6.5.3 DFS与BFS算法效率比较

- 空间复杂度相同，都是O(n)（借用了堆栈或队列）；

- 时间复杂度只与存储结构、（邻接矩阵或邻接表）有关，而与搜索路径无关。

## 6.6 图的应用

### 6.6.1 最小生成树

生成树的共同特点：

- 顶点个数与图的顶点个数相同；

- 是图的极小连通子图，去掉一条边则非连通；

- 一个有n个顶点的连通图的生成树有n-1条边；

- **在生成树中再加一条边必然形成回路**；

- 生成树中的任意两个顶点间的路径是惟一的。

在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的**最小代价生成树**(**Minimum Cost Spanning Tree**)，简称为**最小生成树**。

构造最小生成树有多种算法，其中多数算法利用了最小生成树的下列一种简称为MST的性质：假设N=(V, E)是一个连通网，U是顶点集V的一个非空子集。若(u, v)是一条具有最小权值（代价）的边，其中u∈U，v∈V-U，则必存在一棵包含边(u, v)的最小生成树。

MST性质解释：

在生成树的构造过程中，图中n个顶点分属两个集合：

- 已落在生成树上的顶点集：U

- 尚未落在生成树上的顶点集：V-U

接下来则应在所有连通U中顶点和V-U中顶点的边中选取权值最小的边。

普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法是两个利用MST性质构造最小生成树的算法。下面先介绍普里姆算法。

1. 普里姆算法

    普里姆算法的构造过程：

    假设N=(V,E)是连通网，TE是N上最小生成树中边的集合。

    1. U = {u0}(u0∈V), TE = {}。

    2. 在所有u∈U, v∈V- U的边(u,v)∈E中找一条权值最小的边(u0,v0)并入集合TE，同时v0并入U。

    3. 重复步骤2，直至U = V为止。

    此时TE中必有n-1条边，则T= (V, TE)为N的最小生成树。

    普里姆算法的算法实现：

    假设一个无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，要求输出T的各条边。为实现这个算法需附设一个辅助数组closedge，以记录从U到V-U具有最小权值的边。对每个顶点vi∈V- U，在辅助数组中存在一个相应分量closedge[i-1], 它包括两个域：lowcost和adjvex，其中Iowcost存储最小边上的权值，adjvex存储最小边在U中的那个顶点。显然，closedge[i-1].lowcost = Min{ cost(u, vi)|u∈U}，其中cost(u,v)表示赋于边(u,v)的权。

    ```C++
        // 辅助数组的定义，用来记录从顶点集U到V-U的权值最小的边

        struct
        {
            VerTexType adjvex;      // 最小边在U中的那个顶点
            ArcType lowcost;        // 最小边上的权值
        }closedge[MVNum];
    ```

    算法6.8 普里姆算法

    1. 首先将初始顶点u加入U中，对其余的每一个顶点Vj，将closedge[j]均初始化为到u的边息。

    2. 循环n - 1次，做如下处理：

        - 从各组边closedge中选出最小边closedge[k]，输出此边；

        - 将k加入U中；

        - 更新剩余的每组最小边信息closedge[j]，对于V-U中的边，新增加了一条从k到j的边，如果新边的权值比closedge[i].lowcost小，则将closedge[j].lowcost 更新为新边的权值。

    算法描述：

    ```C++
        void MiniSpanTree_Prim(AMGraph G, VerTexType u)
        {
            // 无向网G以邻接矩阵形式存储，从顶点u出发构造G的最小生成树T，输出T的各条边
            k = LocateVex(G, u);        // k为顶点u的下标
            for(j = 0; j < G.vexnum; ++j)
            {
                if(j != k) closedge[j] = {u, G.arcs[k][j]};
                closedge[k].lowcost = 0;    // 初始，U={u}
                for(int i = 1; i < G.vexnum; ++i)
                {
                    // 求出T的下一个结点：第k个顶点，closedge[k]中存有当前最小边
                    u0 = closedge[k].adjvex;    // u0为最小边的一个顶点
                    v0 = G.vexs[k];             // v0为最小边的另一个顶点
                    cout << u0 << v0;
                    closedge[k].lowcost = 0;
                    for(j = 0; j < G.vexnum; ++j)
                    {
                        if(G.arcs[k][j] < closedge[j].lowcost)
                        {
                            closedge[j] = {G.vexs[k], G.arcs[k][j]};
                        }
                    }
                }
            }
        }
    ```

2. 克鲁斯卡尔算法

    算法步骤：

    1. 将数组Edge中的元素按权值从小到大排序。

    2. 依次查看数组Edge中的边，循环执行以下操作：

        - 依次从排好序的数组Edge中选出一条边(U1,U2)；

        - 在Vexset中分别查找V1和V2所在的连通分量vs1和vs2，进行判断：

            - 如果vs1和vs2不等，表明所选的两个顶点分属不同的连通分量，输出此边，并合并vs1和vs2两个连通分量；

            - 如果vs1和vs2相等，表明所选的两个顶点属于同一个连通分量，舍去此边而选择下一条权值最小的边。

    算法描述：

    ```C++
        void MiniSpanTree_Kruskal(AMGraph G)
        {
            Sort(Edge); // 将数组Edge中的元素按权值从小到大排序
            for(i = 0; i < G.arcnum; i++)
            {
                v1 = LocateVex(G, Edge[i].Head);    // v1为边的始点Head的下标
                v2 = LocateVex(G, Edge[i].Tail);    // v2为边的始点Head的下标
                vs1 = Vexset[v1];   // 获取边Edge[i]的始点所在的连通分量vs1
                vs2 = Vexset[v2];   // 获取边Edge[i]的始点所在的连通分量vs2
                if(vs1 != vs2)
                {
                    cout << Edge[i].Head << Edge[i].Tail;
                    for(j = 0; j < G.vexnum; ++j)
                    {
                        if(Vexset[j] == vs2)
                            Vexset[j] = vsl;
                    }
                }
            }
        }
    ```

### 6.6.2 最短路径

问题抽象：在有向网中A点（源点）到达B点（终点）的多条路径中，寻找一条各边权值之和最小的路径，即最短路径。

在带权有向网中，习惯上称路径上的第一个顶点为源点(Source)，最后一个顶点为终点(Destination)。

针对单源最短路径一用Dijkstra(迪杰断特拉)算法；针对所有顶点间的最短路径一用Floyd(弗洛伊德)算法。

1. Dijistra算法

    1. 初始化：先找出从源点v0到各终点vk的直达路径(v0,vk)，即通过一条弧到达的路径；

    2. 选择：从这些路径中找出一条长度最短的路径(v0,u)；

    3. 更新：然后对其余各条路径进行适当调整：

        若在图中存在弧(u,vk)，且(v0,u)+(u,vk)<(v0,vk)，则以路径(v0,u，vk)代替(v0,vk)。

    在调整后的各条路径中，再找长度最短的路径，依此类推。

    **Dijistra算法：按照长度递增次序产生最短路径。**

    1. 把V分成两组：

        (1) S：已求出最短路径的顶点的集合；

        (2)T=V - S：尚未确定最短路径的顶点解和。

    2. 将T中顶点按最短路径递增的次序加入到S中

        保证：a. 从源点v0到S中各顶点的最短路径长度都不大于从v0到T中任何顶点的最短路径长度。

        b. 每个顶点对应一个距离值：S中顶点：从v0到此顶点的最短路径；T中顶点：从v0到此顶点的只包括S中顶点作中间顶点的最短路径长度。

2. Floyd算法

